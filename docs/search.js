window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "enda", "modulename": "enda", "kind": "module", "doc": "<h1 id=\"enda\">enda</h1>\n\n<p><img src=\"https://img.shields.io/pypi/v/enda\" alt=\"PyPI\" /> <a href=\"https://python-poetry.org/\"><img src=\"https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json\" alt=\"Poetry\" /></a> <a href=\"https://pycqa.github.io/isort/\"><img src=\"https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336\" alt=\"Imports: isort\" /></a> <a href=\"https://github.com/psf/black\"><img src=\"https://img.shields.io/badge/code%20style-black-000000.svg\" alt=\"Code style: black\" /></a> <a href=\"https://github.com/pre-commit/pre-commit\"><img src=\"https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit\" alt=\"pre-commit\" /></a></p>\n\n<h2 id=\"what-is-it\">What is it?</h2>\n\n<p><strong>enda</strong> is a Python package that provides tools to manipulate <strong>timeseries</strong> data in conjunction with <strong>contracts</strong> data for analysis and <strong>forecasting</strong>.</p>\n\n<p>Initially, it has been developed to help <a href=\"https://www.rescoop.eu/\">Rescoop.eu</a> members build various applications, such as short-term electricity load and production forecasts, specifically for the <a href=\"https://www.rescoopvpp.eu/\">RescoopVPP</a> project. Hence some tools in this package perform TSO (transmission network operator) and DNO (distribution network operator) data wrangling as well as weather data management. enda is mainly developed by <a href=\"https://www.enercoop.fr/\">Enercoop</a>.</p>\n\n<h2 id=\"main-features\">Main Features</h2>\n\n<p>Here are some things <strong>enda</strong> does well:</p>\n\n<ul>\n<li>Provide robust machine learning algorithms for <strong>short-term electricity load and production forecasts</strong>. enda provides a convenient wrapper around the popular multipurpose machine-learning backends <a href=\"https://scikit-learn.org/stable/\">Scikit</a> and <a href=\"https://h2o.ai/platform/ai-cloud/make/h2o/\">H2O</a>. The load forecast was originally based on Komi Nagbe's thesis (<a href=\"http://www.theses.fr/s148364\">http://www.theses.fr/s148364</a>).</li>\n<li>Manipulate <strong>timeseries</strong> data, such as load curves. enda handles timeseries-specific detection of missing data, like time gaps, frequency changes, extra values, as well as various resampling methods. </li>\n<li>Provide several <strong>backtesting</strong> and <strong>scoring</strong> methods to ensure the quality of the trained algorithm on almost real conditions.</li>\n<li>Manipulate <strong>contracts</strong> data coming from your ERP and turn it into timeseries you can use for analysis, visualisation and machine learning.</li>\n<li>Date-time <strong>feature engineering</strong> robust to timezone hazards.</li>\n</ul>\n\n<h2 id=\"where-to-get-it\">Where to get it</h2>\n\n<p>The source code is currently hosted on GitHub at: <a href=\"https://github.com/enercoop/enda\">https://github.com/enercoop/enda</a>. If you wish to run the examples it contains, you can clone enda from the Github repository</p>\n\n<p>Binary installers for the latest released version are available at the <a href=\"https://pypi.org/project/enda\">Python\nPackage Index (PyPI)</a> (for now it is not directly on <a href=\"https://docs.conda.io/en/latest/\">Conda</a>). </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>enda\n</code></pre>\n</div>\n\n<p>or using <a href=\"https://python-poetry.org/\">poetry</a>:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>poetry<span class=\"w\"> </span>add<span class=\"w\"> </span>enda\n</code></pre>\n</div>\n\n<h2 id=\"documentation-and-api\">Documentation and API</h2>\n\n<p>The complete API is available online <a href=\"https://enercoop.github.io/enda\">here</a>.</p>\n\n<h2 id=\"how-to-get-started\">How to get started?</h2>\n\n<p>For a more comprehensive approach to enda, several <a href=\"https://jupyter.org/\">Jupyter notebooks</a> have been proposed in the <a href=\"https://github.com/enercoop/enda/tree/main/guides\">guides</a>.\nSome dependencies are needed to run these examples, that you can easily install with poetry, running <code>poetry install enda[examples]</code></p>\n\n<h2 id=\"dependencies\">Dependencies</h2>\n\n<h3 id=\"hard-dependencies\">Hard dependencies</h3>\n\n<ul>\n<li><a href=\"https://pandas.pydata.org/\">Pandas</a></li>\n<li><a href=\"https://scikit-learn.org/stable/\">Scikit-learn</a></li>\n<li><a href=\"https://docs.h2o.ai/\">H2O</a></li>\n<li><a href=\"https://numpy.org/\">Numpy</a></li>\n<li><a href=\"https://pypi.org/project/statsmodels/\">Statsmodels</a></li>\n<li>Libraries that are recommended by the previous packages: <a href=\"https://pypi.org/project/datatable/\">datatable</a>, <a href=\"https://pypi.org/project/polars/\">polars</a>, <a href=\"https://pypi.org/project/numexpr/\">numexpr</a>, <a href=\"https://pypi.org/project/Unidecode/\">unidecode</a></li>\n<li>Libraries meant to get calendar data: <a href=\"https://pypi.org/project/jours-feries-france/\">jours-feries-france</a>, <a href=\"https://pypi.org/project/vacances-scolaires-france/\">vacances-scolaires-france</a></li>\n</ul>\n\n<h3 id=\"optional-dependencies\">Optional dependencies</h3>\n\n<p>If you want to run the examples, you may need extra dependencies. \nThese dependencies can be installed using poetry: </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>poetry<span class=\"w\"> </span>install<span class=\"w\"> </span>--with<span class=\"w\"> </span>examples\n</code></pre>\n</div>\n\n<p>or manually:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>numexpr<span class=\"w\"> </span>bottleneck<span class=\"w\"> </span>pandas<span class=\"w\"> </span>enda<span class=\"w\"> </span>jupyter<span class=\"w\"> </span>h2o<span class=\"w\"> </span>scikit-learn<span class=\"w\"> </span>statsmodels<span class=\"w\"> </span>joblib<span class=\"w\"> </span>matplotlib\n</code></pre>\n</div>\n\n<p>Accordingly, if you wish to develop into enda, we suggest some tools and linters that can be used. </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>poetry<span class=\"w\"> </span>install<span class=\"w\"> </span>--with<span class=\"w\"> </span>dev\n</code></pre>\n</div>\n\n<h2 id=\"license\">License</h2>\n\n<p><a href=\"LICENSE\">MIT</a></p>\n"}, {"fullname": "enda.backtesting", "modulename": "enda.backtesting", "kind": "module", "doc": "<p>A module containing functions used for the backtesting of models</p>\n"}, {"fullname": "enda.backtesting.BackTesting", "modulename": "enda.backtesting", "qualname": "BackTesting", "kind": "class", "doc": "<p>A class to help with back-testing on algorithms.</p>\n"}, {"fullname": "enda.backtesting.BackTesting.yield_train_test", "modulename": "enda.backtesting", "qualname": "BackTesting.yield_train_test", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_eval_datetime</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">days_between_trains</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">gap_days_between_train_and_eval</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.backtesting.BackTesting.yield_train_test_regular_split", "modulename": "enda.backtesting", "qualname": "BackTesting.yield_train_test_regular_split", "kind": "function", "doc": "<p>Returns pairs of (train set, test set) to perform back-testing on the data.\nThe splitting relies on the Scikit object 'TimeSeriesSplit'. The size of the test dataset is determined\nby scikit, so that the dataset can be split into n_splits.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the dataset, a pd.DataFrame with a pd.DatetimeIndex or MultiIndex with last index being\nthe DatetimeIndex.</li>\n<li><strong>n_splits</strong>:  number of splits train-test sets. If none, defaults to 5</li>\n<li><strong>gap_size</strong>:  eg '1D', '1W'... Size of the data between the train and test samples, expressed as a freqstr\nor a pd.Timedelta.</li>\n<li><strong>min_train_size</strong>:  the minimal initial size of the train set, out of the splitting routine.\nnot this does not correspond to the exact size of the first train set, which is min_train_size + test_size</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a generator of (train set, test set) pairs</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">n_splits</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">gap_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;0D&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">min_train_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.backtesting.BackTesting.yield_train_test_periodic_split", "modulename": "enda.backtesting", "qualname": "BackTesting.yield_train_test_periodic_split", "kind": "function", "doc": "<p>Returns pairs of (train set, test set) to perform back-testing on the data.\nThere, we do not indicate the number of splits to perform, but the size of the test dataset, for instance\n    '1M', or '10D'. If min_train_size is None, test_size has the same size as the initial train set.\n    Then, for each iteration, the train set is increased, but the size of the test set remains constant.\n    If the last test sample is smaller than the desired test size, it might not be returned to avoid\n    side effects.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the dataset, a pd.DataFrame with a pd.DatetimeIndex or MultiIndex with last index being\nthe DatetimeIndex.</li>\n<li><strong>test_size</strong>:  eg. '28D', '2M'... Fixed size of the test sample.</li>\n<li><strong>gap_size</strong>:  eg '1D', '1W'... Size of the data between the train and test samples.</li>\n<li><strong>min_train_size</strong>:  the size of the first initial train test. If None, it defaults to test_size.</li>\n<li><strong>min_last_test_size_pct</strong>:  The last test set can be smaller than the desired test_size. This parameter\nis used to control the minimal size of the last test set, based on a percentage of the 'test_set' variable.\nIf the last test set is smaller than min_last_test_size_pct * test_size, it is not returned.\nIt defaults to 0.5 (i.e. the last test set must be greater than half of test_size).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a generator of (train set, test set) pairs</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">test_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">gap_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;0D&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">min_train_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">min_last_test_size_pct</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span></span><span class=\"return-annotation\">) -> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.backtesting.BackTesting.backtest", "modulename": "enda.backtesting", "qualname": "BackTesting.backtest", "kind": "function", "doc": "<p>Backtest an estimator over a dataset. That means performing successive training and prediction on growing\n    timeseries datasets, and compute on each set some scores to estimate the quality of the estimator over the\n    dataset. The backtesting scheme (train/test splits) is defined using either the function\n    yield_train_test_periodic_split() if test_size is given in the arguments of this function, or\n    yield_train_test_regular_split() otherwise.\n    This function returns a dict with two keys, 'score' and 'forecast':\n    - 'score' contains a dataframe with the result of the scoring statistic on each train and test set.\n    - 'forecast' contains a dataframe with the forecast on each test set.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>estimator</strong>:  the EndaEstimator to backtest.</li>\n<li><strong>df</strong>:  the input dataframe on which the estimator is back-tested.</li>\n<li><strong>target_col</strong>:  the target column.</li>\n<li><strong>scores</strong>:  Optional. Define the score function to use for the backtesting.\nIt can be a list of loss functions to estimate as defined in Scoring().\nIt can be a dict of name-methods, and the end-user can provide any function in that case.\nIf nothing is given, it defaults to RMSE.</li>\n<li><strong>process_forecast_specs</strong>:  Optional. If given, it defines a function to apply to the result of\neach prediction before calculating the scoring (it is also applied to the training loss). A typical example\nis the PowerStation.clip_column() function, which is used to clamp the forecast load factor between\n0 and 1.\nprocess_forecast_specs must be a tuple, with the function to be applied, and a dict with all\nthe function keywords arguments names and values.</li>\n<li><strong>retrain_estimator</strong>:  boolean, if True (default), perform a real backtesting during which an\nestimator is retrained before being used to perform a forecast. If False, the estimator must be\nalready trained, and this function only serves to perform successive forecasts on test sets.</li>\n<li><strong>post_iter_hook</strong>:  A function to be called at the end of each iteration of the backtest process.\nFor example, it allows to clean the memory after each iteration when using h2o estimator.</li>\n<li><strong>kwargs</strong>:  extra argument to pass to the chosen split method yield_train_test_regular_split() or\nyield_train_test_periodic_split(), such as n_splits, test_size, gap_size, min_train_size,\nmin_last_test_size_pct...\nIf nothing is given, yield_train_test_regular_split(n_splits=5) is called.</li>\n<li><strong>verbose</strong>:  boolean, defaults False. Print or no information.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dict which contains:\n      - for the 'score' key: a dataframe with the train and test results for each statistics and each split.\n      - for the 'forecast' key: a dataframe with the successive forecasts on the test sets.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">estimator</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">scores</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">process_forecast_specs</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">retrain_estimator</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">post_iter_hook</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.config", "modulename": "enda.config", "kind": "module", "doc": "<p>Config of enda</p>\n"}, {"fullname": "enda.config.LOGGER", "modulename": "enda.config", "qualname": "LOGGER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger enda (WARNING)&gt;"}, {"fullname": "enda.config.logger_handler", "modulename": "enda.config", "qualname": "logger_handler", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;StreamHandler (NOTSET)&gt;"}, {"fullname": "enda.config.logger", "modulename": "enda.config", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger enda (WARNING)&gt;"}, {"fullname": "enda.config.set_logger", "modulename": "enda.config", "qualname": "set_logger", "kind": "function", "doc": "<p>Define a new logger</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">new_logger</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.config.get_logger", "modulename": "enda.config", "qualname": "get_logger", "kind": "function", "doc": "<p>Get the global logger</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts", "modulename": "enda.contracts", "kind": "module", "doc": "<p>This module contains methods useful to handle contracts data</p>\n"}, {"fullname": "enda.contracts.Contracts", "modulename": "enda.contracts", "qualname": "Contracts", "kind": "class", "doc": "<p>A class to help handle contracts data.</p>\n\n<p>contracts : a dataframe with a contract or subcontract on each row.\n    A contract row has fixed-values between two dates. In some systems, some values of a contract can change over\n    time, for instance the \"subscribed power\" of an electricity consumption contract.\n    Different ERPs can handle it in different ways, for instance with \"subcontracts\" inside a contract\n    or with contract \"amendments\".\n    Here each row is a period between two dates where all the values of the contract are fixed.</p>\n\n<pre><code>Columns can be like in example_a.csv :\n[customer_id,\n contract_id,\n date_start,\n date_end_exclusive,  # contract ends at 00h00 that day, so that day is excluded from the contract period.\n sub_contract_end_reason,\n subscribed_power_kva,\n smart_metered,\n profile,\n customer_type,\n specific_price,\n estimated_annual_consumption_kwh,\n tension]\n</code></pre>\n\n<p>Columns [date_start, date_end_exclusive] are required (names can differ), and with dtype=datetime64 (tz-naive).\nOther columns describe contract characteristics.</p>\n"}, {"fullname": "enda.contracts.Contracts.read_contracts_from_file", "modulename": "enda.contracts", "qualname": "Contracts.read_contracts_from_file", "kind": "function", "doc": "<p>Reads contracts from a file. This will convert start and end date columns into dtype=datetime64 (tz-naive)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  where the source file is located.</li>\n<li><strong>date_start_col</strong>:  the name of your contract date start column.</li>\n<li><strong>date_end_exclusive_col</strong>:  the name of your contract date end column, end date is exclusive.</li>\n<li><strong>date_format</strong>:  the date format for pandas.to_datetime.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a pandas.DataFrame with a contract on each row.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_start&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_end_exclusive&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_format</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts.Contracts.check_contracts_dates", "modulename": "enda.contracts", "qualname": "Contracts.check_contracts_dates", "kind": "function", "doc": "<p>Checks that the two columns, date_start_col and date_end_exclusive_col, are present.\nChecks that date_start does not have any null value.\nA date_end_exclusive==NaT means that the contract has no limited duration.\nChecks that date_start &lt; date_end_exclusive when date_end_exclusive is set\nIf is_naive is set to True, check that timestamps in date_start_col and date_end_exclusive_col are naive\nIf any of these checks fail, raise a ValueError</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the pandas.DataFrame containing the contracts</li>\n<li><strong>date_start_col</strong>:  the name of your contract date start column.</li>\n<li><strong>date_end_exclusive_col</strong>:  the name of your contract date end column, end date is exclusive.</li>\n<li><strong>is_naive</strong>:  whether the timestamps in the start and end dates columns are supposed to be naive</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">is_naive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts.Contracts.compute_portfolio_by_day", "modulename": "enda.contracts", "qualname": "Contracts.compute_portfolio_by_day", "kind": "function", "doc": "<p>Given a list of contracts_with_group ,</p>\n\n<p>Returns the \"portfolio\" by day, which is, for each day from the first start of a contract\nto the last end of a contract, the quantities in \"columns_to_sum\" over time.\nSee unittests or enda's guides for examples.</p>\n\n<p>If you want to compute the quantities for a group of customers, filter contracts before using this function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>contracts</strong>:  the dataframe containing the list of contracts to consider.\nEach contract has at least these columns :\n    [\"date_start\", \"date_end_exclusive\", and all columns_to_sum]\n    each column in columns_to_sum must be of a summable dtype</li>\n<li><strong>columns_to_sum</strong>:  the columns on which to compute a running-sum over time</li>\n<li><strong>date_start_col</strong>:  the name of your contract date start column.</li>\n<li><strong>date_end_exclusive_col</strong>:  the name of your contract date end column, end date is exclusive.</li>\n<li><strong>max_date_exclusive</strong>:  restricts the output to strictly before this date.\nUseful if you have end_dates far in the future.</li>\n<li><strong>ffill_until_max_date</strong>:  Whether to forward fill the last available value until max_date_exclusive.\nDefault False</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a 'portfolio' dataframe with one day per row,\n           and the following column hierarchy: (columns_to_sum, group_column)\n           Each day, we have the running sum of each columns_to_sum, for each group of contracts.\n           The first row is the earliest contract start date and the last row is the latest\n           contract start or contract end date.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">contracts</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">columns_to_sum</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_start&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_end_exclusive&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_date_exclusive</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ffill_until_max_date</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts.Contracts.get_portfolio_between_dates", "modulename": "enda.contracts", "qualname": "Contracts.get_portfolio_between_dates", "kind": "function", "doc": "<p>Keeps portfolio data between the specified dates.\nIf the first date in portfolio is after start_datetime, we add missing dates with 0 as value.\nIf the last date in portfolio is before end_datetime_exclusive, we forward fill the last present values\nuntil end_datetime_exclusive</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>portfolio</strong>:  The portfolio DataFrame. It must have a pd.DatetimeIndex with a frequency</li>\n<li><strong>start_datetime</strong>:  The start datetime from which to keep the portfolio</li>\n<li><strong>end_datetime_exclusive</strong>:  The exclusive end datetime until which to keep the portfolio</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A portfolio DataFrame with values between specified dates</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">portfolio</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_datetime</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">end_datetime_exclusive</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts.Contracts.forecast_portfolio_linear", "modulename": "enda.contracts", "qualname": "Contracts.forecast_portfolio_linear", "kind": "function", "doc": "<p>Forecast portfolio using a linear extrapolation for the next nb_days\nThe output has the frequency which is given as an input, and defaults to the one of input portfolio_df\n if nothing is provided.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>portfolio_df</strong>:  The portfolio DataFrame to perform the forecast on</li>\n<li><strong>start_forecast_date</strong>:  The start datetime from which to extend the portfolio</li>\n<li><strong>end_forecast_date_exclusive</strong>:  The exclusive end datetime until which to extend the portfolio</li>\n<li><strong>freq</strong>:  The frequency of the resulting linearly-extrapolated portfolio</li>\n<li><strong>max_allowed_gap</strong>:  The max gap between the end of the portfolio and the start date of the extrapolation.\nReturns an error if exceeded.</li>\n<li><strong>tzinfo</strong>:  The time-zone of the resulting dataframe, if we want to change it.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame (the linearly-extrapolated forecast portfolio data)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">portfolio_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_forecast_date</span>,</span><span class=\"param\">\t<span class=\"n\">end_forecast_date_exclusive</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;] = None,</span><span class=\"param\">\t<span class=\"n\">max_allowed_gap</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span> <span class=\"o\">=</span> <span class=\"n\">Timedelta</span><span class=\"p\">(</span><span class=\"s1\">&#39;1 days 00:00:00&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\ttzinfo: [&lt;function timezone&gt;, &lt;class &#x27;str&#x27;&gt;, None] = None</span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.contracts.Contracts.forecast_portfolio_holt", "modulename": "enda.contracts", "qualname": "Contracts.forecast_portfolio_holt", "kind": "function", "doc": "<p>Forecast using exponential smoothing (Holt method) for the next nb_days\nThe output has the same frequency as input portfolio_df.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>portfolio_df</strong>:  The portfolio DataFrame to perform the forecast on</li>\n<li><strong>start_forecast_date</strong>:  when we stop the portfolio data and start forecasting</li>\n<li><strong>nb_days</strong>:  number of days after 'end_date' to forecast</li>\n<li><strong>past_days</strong>:  max number of days to use in the past used to make the forecast\n(it is better to use only recent data)</li>\n<li><strong>holt_init_params: the dict of parameters to give to the Holt __init__ method. If none, defaults to</strong>: \nholt_fit_params={\"initialization_method\":\"estimated\"}\nFor more details see the statsmodels documentation :\n<a href=\"https://www.statsmodels.org/stable/examples/notebooks/generated/exponential_smoothing.html\">https://www.statsmodels.org/stable/examples/notebooks/generated/exponential_smoothing.html</a></li>\n<li><strong>holt_fit_params: the dict of params to give to the Holt.fit() method. If none, defaults to</strong>:  {}</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame (the forecast data)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">portfolio_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_forecast_date</span>,</span><span class=\"param\">\t<span class=\"n\">nb_days</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">14</span>,</span><span class=\"param\">\t<span class=\"n\">past_days</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">holt_init_params</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">holt_fit_params</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators", "modulename": "enda.estimators", "kind": "module", "doc": "<p>This module contains several basic machine learning estimators</p>\n"}, {"fullname": "enda.estimators.EndaEstimator", "modulename": "enda.estimators", "qualname": "EndaEstimator", "kind": "class", "doc": "<p>This interface represents a simple machine learning estimator with some universal functions.\nWe require these functions :\n    train : train the estimator\n    predict : predict using the estimator\n    get_model_params : return the hyperparameters of the model</p>\n\n<p>To save and load instances of a class, use tools like pickle or joblib\n(see information for instance here: https://scikit-learn.org/stable/modules/model_persistence.html).</p>\n\n<p>This interface is useful to create more advanced estimators based on these building blocks :\n    EndaNormalizedEstimator : uses one of the inputs as a 'normalization variable' instead of a 'training feature'.\n    EndaStackingEstimator : combines several estimators to create a more robust estimator\n                            (cross-algorithm 'ensemble' method).\n    EndaEstimatorWithFallback : an estimator that can cope with missing input in a robust way.</p>\n\n<p>See tutorials about Python interfaces for instance here <a href=\"https://realpython.com/python-interface/\">https://realpython.com/python-interface/</a> .</p>\n"}, {"fullname": "enda.estimators.EndaEstimator.train", "modulename": "enda.estimators", "qualname": "EndaEstimator.train", "kind": "function", "doc": "<p>Trains the estimator using the given data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.fit", "modulename": "enda.estimators", "qualname": "EndaEstimator.fit", "kind": "function", "doc": "<p>Trains the estimator using the given data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.predict", "modulename": "enda.estimators", "qualname": "EndaEstimator.predict", "kind": "function", "doc": "<p>Predicts and returns a dataframe with just 1 column: target_col_name</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.get_model_name", "modulename": "enda.estimators", "qualname": "EndaEstimator.get_model_name", "kind": "function", "doc": "<p>Return the estimator name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.get_model_params", "modulename": "enda.estimators", "qualname": "EndaEstimator.get_model_params", "kind": "function", "doc": "<p>Return a dict with the model name and hyperparameters</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.get_loss_training", "modulename": "enda.estimators", "qualname": "EndaEstimator.get_loss_training", "kind": "function", "doc": "<p>Compute the training loss, i.e. the error of the trained model on the training dataset.\n If not overridden (eg. in H2OEstimator), this function computes the loss on the training\n dataset, using scikit-learn built-in methods.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scores</strong>:  the statistics to consider. It can be a list of enda-known functions, a home-made function\n(if given as a dict), or RMSE if nothing is provided.</li>\n<li><strong>process_forecast_specs</strong>:  Optional. If given, it defines a function to apply to the forecast before\ncalculating the loss.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a series that contains for each statistics the score of the model on the training set</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">scores</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">process_forecast_specs</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimator.get_feature_importance", "modulename": "enda.estimators", "qualname": "EndaEstimator.get_feature_importance", "kind": "function", "doc": "<p>Return the feature's importance once a model has been trained.\nSuch a feature is usually not implemented, except for some algorithm in\nparticular (let's say, sklearn and H2O, and not all of them)</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a series that contain the percentage of importance for each variable</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaNormalizedEstimator", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator", "kind": "class", "doc": "<p>An estimator that uses one of the inputs as a linear 'normalization variable' instead of a 'training feature'.\nThe prediction is:\npredict(X) = X[normalization_col] * predict(X without normalization_col)</p>\n\n<p>predict(X without normalization_col) is made by another underlying estimator: inner_estimator.</p>\n", "bases": "EndaEstimator"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.__init__", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.__init__", "kind": "function", "doc": "<p>Initialize the normalized estimator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>inner_estimator</strong>:  the estimator that will perform predict(X without normalization_col)</li>\n<li><strong>normalization_col</strong>:  name of the column used as a multiplier and not as a feature.</li>\n<li><strong>columns_to_normalize</strong>:  (optional) columns in 'X without normalization_col' that must be divided\nby normalization_col for the underlying estimator to train/predict correctly.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">inner_estimator</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">normalization_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">columns_to_normalize</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.inner_estimator", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.inner_estimator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.target_col", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.target_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.normalisation_col", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.normalisation_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.columns_to_normalize", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.columns_to_normalize", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.get_model_params", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.get_model_params", "kind": "function", "doc": "<p>Return a dict with the model name and hyperparameters</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.check_normalization_col", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.check_normalization_col", "kind": "function", "doc": "<p>Checks that the values of the normalization col in the input DataFrame are strictly positive, otherwise\nraise an error</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The DataFrame to check</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.normalize", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.normalize", "kind": "function", "doc": "<p>Checks that the normalization column has only strictly positive values, then normalizes the columns of the\nDataFrame that are in the columns_to_normalize attribute by dividing them by the normalization column. Also\nnormalizes the target_col if it is in the DataFrame columns. Then, drops normalization_col</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The DataFrame to normalize</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The DataFrame with columns part of columns_to_normalize or the target_col column normalized, and\n      without the normalization_col</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.train", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.train", "kind": "function", "doc": "<p>Normalizes the DataFrame and trains the inner estimator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The training DataFrame</li>\n<li><strong>target_col</strong>:  The variable to predict</li>\n<li><strong>drop_where_normalization_under_zero</strong>:  Whether to drop rows where normalization_col is not strictly\npositive. Note that the normalize function will raise an error if there is still negative values in\nnormalization_col</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">drop_where_normalization_under_zero</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaNormalizedEstimator.predict", "modulename": "enda.estimators", "qualname": "EndaNormalizedEstimator.predict", "kind": "function", "doc": "<p>Normalizes the input DataFrame, then uses the inner estimator to make a prediction on target_col. Then,\nmultiplies the result by the normalization_col to get the final prediction</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The forecast input DataFrame</li>\n<li><strong>target_col</strong>:  The variable to predict</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The final prediction of the estimator</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator", "kind": "class", "doc": "<p>This class serves the same purpose as the Scikit-Learn \"Stacking Regressor\". However since we work on\ntime-series, we need fine control on which data is passed to train the base_estimators before training\nthe final_estimator (to keep it all chronologically consistent).</p>\n\n<p>Training is made this way :\n    temporarily train base_estimators on train_set[:x]\n    use base_estimators to predict on train_set[x:] -> base_predictions\n    train final_estimator on the base_predictions\n    re-train base_estimators on the full train-set\nWe have to train base_estimators twice, because if we trained them on the full set and then predict on\ntrain_set[x:] for training final_estimator, we would be making a prediction on part of the data that was used to\ntrain them, which would be a huge risk of over-fitting</p>\n", "bases": "EndaEstimator"}, {"fullname": "enda.estimators.EndaStackingEstimator.__init__", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.__init__", "kind": "function", "doc": "<p>Initialize the stacking estimator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>base_estimators</strong>:  a dict of {estimator_id -> estimator}, each estimator (there must be at least 2) must\nbe an EndaEstimator.</li>\n<li><strong>final_estimator</strong>:  the estimator used for stacking, must also implement be an EndaEstimator.</li>\n<li><strong>base_stack_split_pct</strong>:  the % of data used to train the base_estimators before training final_estimator\n(this can be overwritten in the train function).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">base_estimators</span><span class=\"p\">:</span> <span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">final_estimator</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span>,</span><span class=\"param\">\t<span class=\"n\">base_stack_split_pct</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span></span>)</span>"}, {"fullname": "enda.estimators.EndaStackingEstimator.base_estimators", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.base_estimators", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaStackingEstimator.final_estimator", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.final_estimator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaStackingEstimator.base_stack_split_pct", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.base_stack_split_pct", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaStackingEstimator.train", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.train", "kind": "function", "doc": "<p>Train base and final estimators.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The training dataset</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n<li><strong>base_stack_split_pct</strong>:  If specified, will overwrite the EndaStackingEstimator attribute.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\tbase_stack_split_pct: [&lt;class &#x27;float&#x27;&gt;, None] = None</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.train_final_estimator", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.train_final_estimator", "kind": "function", "doc": "<p>Trains the final estimator used for stacking.\n(Temporarily) train the single estimators with a subset of the data,\nthen apply them on the rest of the data. Use this to train the stacking estimator.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The DataFrame with training data</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n<li><strong>split_pct</strong>:  The percentage of training data to use to train the base estimators. The rest of the data\nwill be used to train the final estimator based on the predictions of the base estimators</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">split_pct</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.predict_base_estimators", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.predict_base_estimators", "kind": "function", "doc": "<p>Make a prediction using base estimators</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input DataFrame for prediction</li>\n<li><strong>target_col</strong>:  The name of the column to predict</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a Dataframe with the prediction of each base estimator in each column (on several rows).\n      Each column's name is the estimator_id given on initialisation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.train_base_estimators", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.train_base_estimators", "kind": "function", "doc": "<p>Train the base estimators</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The training data</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.predict", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.predict", "kind": "function", "doc": "<p>Make predictions with base estimators, then uses them to make a prediction with the final estimator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input data for prediction</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame with the predicted column</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.get_model_params", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.get_model_params", "kind": "function", "doc": "<p>Get model parameters of estimators (each of base_estimator) and final_estimator\nThe principle is to return the model params as  a dict with two entries, base_estimators, and final_estimator\nEach of these entries contains a dictionary as well, with the model name as a key, and model parameters\nas values.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with one entry per model and associated parameters</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaStackingEstimator.get_all_model_names", "modulename": "enda.estimators", "qualname": "EndaStackingEstimator.get_all_model_names", "kind": "function", "doc": "<p>Get name of all base models, plus name of final model\nin a dictionary with two entries, \"base_estimator\" and \"final_estimator\"</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback", "kind": "class", "doc": "<p>This estimator allows to make a prediction even when some important input is missing.</p>\n\n<p>In order to deal with missing values, it is common practice to replace None/NA with some meaningful value like\nthe mean or the median of the values found in the train set for this feature.\nHowever, this is problematic when the missing variable has a significant impact on the prediction.</p>\n\n<p>Instead, this estimator trains 2 underlying estimators:\nan 'estimator_with' and an 'estimator_without' the column that can be missing.\nWhen predicting, it will use the 'estimator_with' for inputs with the column present\nand the 'estimator_without' for the others.</p>\n", "bases": "EndaEstimator"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.__init__", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.__init__", "kind": "function", "doc": "<p>Initialize the estimator</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>resilient_column</strong>:  The column that can be missing, which will be taken into account by estimator_with but\nnot by estimator_without</li>\n<li><strong>estimator_with</strong>:  An EndaEstimator that will train/predict using resilient_column</li>\n<li><strong>estimator_without</strong>:  An EndaEstimator that will train/predict without using resilient_column</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">resilient_column</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">estimator_with</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span>,</span><span class=\"param\">\t<span class=\"n\">estimator_without</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span></span>)</span>"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.resilient_column", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.resilient_column", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.estimator_with", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.estimator_with", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.estimator_without", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.estimator_without", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.train", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.train", "kind": "function", "doc": "<p>Trains the two estimators : estimator_with and estimator_without the resilient_column</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input data for training</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.predict_both", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.predict_both", "kind": "function", "doc": "<p>Makes predictions with both estimators: estimator_with and estimator_without the resilient_column</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input data for prediction</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple with two DataFrames, the first one being the prediction with the resilient_column and the\n      second one without</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;, &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.predict", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.predict", "kind": "function", "doc": "<p>Makes a prediction with both estimators, takes prediction by estimator_with by default and fallbacks to\nestimator_without when it is not available</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input data for prediction</li>\n<li><strong>target_col</strong>:  The column to predict</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The final prediction combining both estimators</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.get_model_params", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.get_model_params", "kind": "function", "doc": "<p>Get model parameters of estimator_with and estimator_without.\nThe principle is to store the model params as a dict with two entries, estimator_with, and estimator_without\nEach of these entries contains a dictionary as well, with the model params as a key, and model parameters\nas values.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with one entry per model and associated parameters</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorWithFallback.get_all_model_names", "modulename": "enda.estimators", "qualname": "EndaEstimatorWithFallback.get_all_model_names", "kind": "function", "doc": "<p>Get names of sub-model in a dictionary.\nin a dictionary with two entries, \"estimator_with\" and \"estimator_without\"</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorRecopy", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy", "kind": "class", "doc": "<p>This estimator is used to recopy the information\nIt is notably used to predict the production of river power plants, for which no\nartificial intelligence is relevant.\nIt simply recopies the most recent data on a daily basis.</p>\n", "bases": "EndaEstimator"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.__init__", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.__init__", "kind": "function", "doc": "<p>Set up the attribute data that will store the dataframe</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>period</strong>:  The period on which past data should be averaged to be used as future value.\nIt must be convertible to a pd.Timedelta object, eg '1D', '2H', etc...\nIf nothing is provided, the last past value is used in the future</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\tperiod: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;] = None</span>)</span>"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.period", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.period", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.training_data", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.training_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.train", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.train", "kind": "function", "doc": "<p>This function keeps the more recent data of the input dataframe,\nand stores it in the attribute training_data. If a period has been\ngiven to the estimator constructor, it is used to define a period on\nwhich to average the data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input dataframe, with a single DatetimeIndex</li>\n<li><strong>target_col</strong>:  the target column</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.predict", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.predict", "kind": "function", "doc": "<p>Make a prediction just copying the retained information.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input forecast dataframe, with a single DatetimeIndex</li>\n<li><strong>target_col</strong>:  the target column</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.estimators.EndaEstimatorRecopy.get_model_params", "modulename": "enda.estimators", "qualname": "EndaEstimatorRecopy.get_model_params", "kind": "function", "doc": "<p>Get model parameters of estimator_with and estimator_without</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with one entry per model and associated parameters</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering", "modulename": "enda.feature_engineering", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "enda.feature_engineering.calendar", "modulename": "enda.feature_engineering.calendar", "kind": "module", "doc": "<p>A module useful for knowing special days such as public/school holidays or lockdown periods</p>\n"}, {"fullname": "enda.feature_engineering.calendar.TZ_PARIS", "modulename": "enda.feature_engineering.calendar", "qualname": "TZ_PARIS", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;Europe/Paris&#x27;"}, {"fullname": "enda.feature_engineering.calendar.Holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "Holidays", "kind": "class", "doc": "<p>Factory class to gather holidays for different countries</p>\n"}, {"fullname": "enda.feature_engineering.calendar.Holidays.get_public_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "Holidays.get_public_holidays", "kind": "function", "doc": "<p>Return public holidays for a year, and a country</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  the country for which holidays must be returned</li>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataframe with the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Holidays.get_school_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "Holidays.get_school_holidays", "kind": "function", "doc": "<p>Return school holidays for a list of years, and a country</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  the country for which holidays must be returned</li>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataframe with the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseHolidays", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseHolidays", "kind": "class", "doc": "<p>Base class for holidays (public and schools)</p>\n"}, {"fullname": "enda.feature_engineering.calendar.BaseHolidays.get_public_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseHolidays.get_public_holidays", "kind": "function", "doc": "<p>Return public holidays for a list of year, and a country</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>orientation</strong>:  rows or columns</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of datetime which are the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orientation</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;rows&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseHolidays.get_school_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseHolidays.get_school_holidays", "kind": "function", "doc": "<p>Return school holidays for a list of year</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of datetime which are the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.FrenchHolidays", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchHolidays", "kind": "class", "doc": "<p>Child class for French holidays (public and schools)</p>\n", "bases": "BaseHolidays"}, {"fullname": "enda.feature_engineering.calendar.FrenchHolidays.get_public_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchHolidays.get_public_holidays", "kind": "function", "doc": "<p>Return public French holidays for a list of years</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>orientation</strong>:  'rows' (default) or 'columns'. The way to orient the dataframe</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of datetime which are the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orientation</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;rows&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.FrenchHolidays.get_school_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchHolidays.get_school_holidays", "kind": "function", "doc": "<p>Return school holidays for a list of year</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of datetime which are the school holidays for the concerned country</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar", "kind": "class", "doc": "<p>Factory class allowing to gather special days (lockdowns, long weekends) for a given country</p>\n"}, {"fullname": "enda.feature_engineering.calendar.Calendar.get_lockdown", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.get_lockdown", "kind": "function", "doc": "<p>Return a dataframe indicating for each day if a national lockdown was ongoing.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  the list of target years</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataframe with a daily DatetimeIndex and a float 'lockdown' column containing\n           1 if the day is within a lockdown period and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.get_public_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.get_public_holidays", "kind": "function", "doc": "<p>Return a dataframe (at max from 2000-01-01 to 2050-12-31) indicating for each day\nwhether it is a public holiday (denoted by a 1) or not (denoted by a 0)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataFrame with a daily DatetimeIndex and a float 'public holiday' column containing\n           1 if the day is a public holiday and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.get_extra_long_weekend", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.get_extra_long_weekend", "kind": "function", "doc": "<p>Return a dataframe (at max from 2000-01-01 to 2050-12-31) indicating for each day</p>\n\n<ul>\n<li>if the previous (resp. the next day) is a public holiday\nAND</li>\n<li>if the current day is a friday (resp. a monday)\nIf both conditions are fulfilled then the day is denoted by a 1 (0 otherwise)</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  the list of target years</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a DataFrame with a daily DatetimeIndex and an int 'extra_long_weekend' column containing 1 if\n           the day meets the criteria described above and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.feature_special_days", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.feature_special_days", "kind": "function", "doc": "<p>Return a DataFrame featuring all special days</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  list of years for which special days must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n<li><strong>freq</strong>:  A string indicating the frequency at which to interpolate the DataFrame</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;30min&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.interpolate_daily_to_subdaily_data", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.interpolate_daily_to_subdaily_data", "kind": "function", "doc": "<p>Interpolate daily data in a dataframe (with a DatetimeIndex) to sub-daily data using a given method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  pd.DataFrame</li>\n<li><strong>freq</strong>:  a frequency &lt; 'D' (e.g. 'H', '30min', '15min', etc.)</li>\n<li><strong>method</strong>:  how data is interpolated between two consecutive dates (e.g. 'ffill', 'linear', etc.)</li>\n<li><strong>tz</strong>:  timezone (TZ_Paris)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;ffill&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tz</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Europe/Paris&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.get_school_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.get_school_holidays", "kind": "function", "doc": "<p>Return number of school areas off in France</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.Calendar.get_french_lockdown", "modulename": "enda.feature_engineering.calendar", "qualname": "Calendar.get_french_lockdown", "kind": "function", "doc": "<p>Return lockdown days for France</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseCalendar", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseCalendar", "kind": "class", "doc": "<p>Base class allowing to define functions meant to gather special days\n(lockdowns, long weekends) for a given country</p>\n"}, {"fullname": "enda.feature_engineering.calendar.BaseCalendar.get_lockdown", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseCalendar.get_lockdown", "kind": "function", "doc": "<p>Return a dataframe indicating for each day if a national lockdown was ongoing.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  the list of target years</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataframe with a daily DatetimeIndex and a float 'lockdown' column containing\n           1 if the day is within a lockdown period and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseCalendar.get_public_holidays", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseCalendar.get_public_holidays", "kind": "function", "doc": "<p>Return a dataframe (at max from 2000-01-01 to 2050-12-31) indicating for each day\nwhether it is a public holiday (denoted by a 1) or not (denoted by a 0)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  list of years for which holidays must be returned</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataFrame with a daily DatetimeIndex and a float 'public holiday' column containing\n           1 if the day is a public holiday and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;FR&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseCalendar.get_extra_long_weekend", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseCalendar.get_extra_long_weekend", "kind": "function", "doc": "<p>Return a dataframe (at max from 2000-01-01 to 2050-12-31) indicating for each day</p>\n\n<ul>\n<li>if the previous (resp. the next day) is a public holiday\nAND</li>\n<li>if the current day is a friday (resp. a monday)\nIf both conditions are fulfilled then the day is denoted by a 1 (0 otherwise)</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>country</strong>:  country of interest</li>\n<li><strong>years_list</strong>:  the list of target years</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a DataFrame with a daily DatetimeIndex and an int 'extra_long_weekend' column containing 1 if\n           the day meets the criteria described above and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;FR&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.BaseCalendar.feature_special_days", "modulename": "enda.feature_engineering.calendar", "qualname": "BaseCalendar.feature_special_days", "kind": "function", "doc": "<p>Return a DataFrame featuring all special days</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  list of years for which special days must be returned</li>\n<li><strong>freq</strong>:  A string indicating the frequency at which to interpolate the DataFrame</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;30min&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.FrenchCalendar", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchCalendar", "kind": "class", "doc": "<p>Child class for French calendar</p>\n", "bases": "BaseCalendar"}, {"fullname": "enda.feature_engineering.calendar.FrenchCalendar.get_lockdown", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchCalendar.get_lockdown", "kind": "function", "doc": "<p>Return a dataframe from indicating for each day if national lockdown was ongoing.\nSo far, the main lockdown period goes from 2020-03-17 to 2020-05-11.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  the list of target years</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dataframe with a daily DatetimeIndex and a float 'lockdown' column containing\n           1 if the day is within a lockdown period and 0 otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.FrenchCalendar.get_number_school_areas_off", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchCalendar.get_number_school_areas_off", "kind": "function", "doc": "<p>Return a dataframe from 2000-01-01 to as far as possible indicating for each day\nthe number of school areas (zone A, B et C) in vacation (either 0, 1, 2 or 3)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  the list of target years</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a DataFrame with a daily DatetimeIndex and a float 'nb_schools_area_off'\n           column indicating the number of school areas in vacation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.calendar.FrenchCalendar.feature_special_days", "modulename": "enda.feature_engineering.calendar", "qualname": "FrenchCalendar.feature_special_days", "kind": "function", "doc": "<p>Return a DataFrame containing all special french days: public and school holidays, lockdowns, and extra long\n    weekends</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>years_list</strong>:  the list of years</li>\n<li><strong>freq</strong>:  A string indicating the frequency at which to interpolate the DataFrame</li>\n<li><strong>index_name</strong>: A string indicating the name of the resulting index</li>\n<li><strong>handling_missing_year</strong>:  either 'warning' (default)  or 'error' or 'silent'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>A DataFrame with a DatetimeIndex at the specified frequency, and 4 float columns :\n- The 'lockdown' column contains 1 if the timestamp is within a lockdown period and 0 otherwise\n- The 'public_holiday' column contains 1 if the day is a public holiday and 0 otherwise\n- The 'nb_school_areas_off' indicates the number of French zones (3 zones : A, B and C) that are in\nschool holidays\n- The 'extra_long_weekend' contains 1 if the day is part of a long weekend (a Monday with a public holiday\non Tuesday, or a Friday with a public holiday in Thursday) and 0 otherwise\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;30min&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">handling_missing_year</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;warning&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features", "modulename": "enda.feature_engineering.datetime_features", "kind": "module", "doc": "<p>This module helps for preprocessing timeseries, by splitting them by attributes such as minutes and hours, and\nalso by encoding features based on these attributes</p>\n"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature", "kind": "class", "doc": "<p>A class containing methods to split datetimes into attributes, and encode these attributes with trigonometric\nfunctions (mainly to be usable by machine learning algorithms)</p>\n"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.split_datetime", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.split_datetime", "kind": "function", "doc": "<p>Split a specific datetime column or datetime index into different date and time attributes (given by split list)\nReturn the dataframe df with the new columns.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  pd.DataFrame</li>\n<li><strong>split_list</strong>:  attributes in ['minute', 'minuteofday', 'hour', 'day', 'month', 'year', 'dayofweek',\n'weekofyear', 'dayofyear']</li>\n<li><strong>index</strong>:  Bool (True if working on a DatetimeIndex, False if working on a column)</li>\n<li><strong>colname</strong>:  str (only if index=False)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame with new columns (split_list)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">split_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">colname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.get_nb_hours_in_day", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.get_nb_hours_in_day", "kind": "function", "doc": "<p>Return the number of hours in the day containing the specified timestamp</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>d</strong>:  A pandas Timestamp object</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An integer</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.daylight_saving_time_dates", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.daylight_saving_time_dates", "kind": "function", "doc": "<p>Return a pd.Dataframe with</p>\n\n<ul>\n<li>as index : the dates when daylight saving time starts or ends for the specified timezone</li>\n<li>as column : the number of hour in this particular day (23 or 25)\nExample :\nnb_hour\n1995-03-26 00:00:00+01:00       23\n1995-09-24 00:00:00+02:00       25\n1996-03-31 00:00:00+01:00       23\n    ...\n2027-10-31 00:00:00+02:00       25\n2028-03-26 00:00:00+01:00       23</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tz</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Europe/Paris&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.encode_cyclic_datetime", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.encode_cyclic_datetime", "kind": "function", "doc": "<p>Get the cyclic properties of a datetime, represented as points on the unit circle.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>d</strong>:  A pd.Timestamp object</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame containing the sine and cosine for following attributes : minute, minuteofday, hour,\n      day, month and dayofweek. Each value is contained in a column (so we have columns such as minute_cos,\n      hour_sin ...) and the input DataFrame is the index</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.encode_cyclic_datetime_index", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.encode_cyclic_datetime_index", "kind": "function", "doc": "<p>Split and encode a datetime index into different date and time attributes (given by split list).\nEncoding method : for each attribute, cosinus and sinus are provided.\nReturn the DataFrame df with the new columns.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input DataFrame with a DatetimeIndex</li>\n<li><strong>split_list</strong>:  attributes in ['minute', 'minuteofday', 'hour', 'day', 'month', 'dayofweek', 'dayofyear']</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame with new columns ['hour_cos', 'hour_sin', 'day_cos', ...]</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">split_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.feature_engineering.datetime_features.DatetimeFeature.get_datetime_features", "modulename": "enda.feature_engineering.datetime_features", "qualname": "DatetimeFeature.get_datetime_features", "kind": "function", "doc": "<p>This function makes successive calls to encode_cyclic_datetime_index() and to split_datetime()</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input DataFrame with a DatetimeIndex</li>\n<li><strong>split_list</strong>:  attributes in ['minute', 'minuteofday', 'hour', 'day', 'month', 'dayofweek', 'dayofyear']</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The DataFrame with new columns resulting from encoding/splitting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">split_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends", "modulename": "enda.ml_backends", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "enda.ml_backends.h2o_estimator", "modulename": "enda.ml_backends.h2o_estimator", "kind": "module", "doc": "<p>This script contains a wrapper for H20 estimators</p>\n"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator", "kind": "class", "doc": "<p>This is a wrapper around any H2O estimator (or anything with the same train/predict methods).\nH2OEstimator implements enda's ModelInterface.</p>\n\n<p>If you have a large dataset and need it on the h2o cluster only,\nusing a H2OFrame exclusively and not in a pandas.Dataframe,\njust use your H2O model directly to train and predict and copy some lines found here.</p>\n\n<p>H2O saves model data on the h2o server, so we cannot simply use pickle/joblib out of the box for these\nobjects. So we have methods for that.</p>\n", "bases": "enda.estimators.EndaEstimator"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.__init__", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">h2o_estimator</span></span>)</span>"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.model", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.train", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.train", "kind": "function", "doc": "<p>Train a h2o-based model from an input dataframe with features and a target column</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the input dataframe</li>\n<li><strong>target_col</strong>:  the target column name</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.predict", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.predict", "kind": "function", "doc": "<p>Predict from a h2o-based trained model using an input dataframe with features</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the input dataframe</li>\n<li><strong>target_col</strong>:  the target column name</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a single-column dataframe with the predicted target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.get_model_name", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.get_model_name", "kind": "function", "doc": "<p>Return the H2O model name instead of EndaH2OEstimator</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.get_model_params", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.get_model_params", "kind": "function", "doc": "<p>Return a dict with the model name and the model hyperparameters</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.h2o_estimator.EndaH2OEstimator.get_feature_importance", "modulename": "enda.ml_backends.h2o_estimator", "qualname": "EndaH2OEstimator.get_feature_importance", "kind": "function", "doc": "<p>Return the feature's importance once a model has been trained.\nThis makes use of built-in method 'varimp' of an H2OEstimator,\nand only returns the percentage column</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a series that contain the percentage of importance for each variable</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.sklearn_estimator", "modulename": "enda.ml_backends.sklearn_estimator", "kind": "module", "doc": "<p>This script contains a wrapper for scikit-learn estimators</p>\n"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator", "kind": "class", "doc": "<p>This is a simple wrapper around any Scikit-learn estimator.\nIt makes it easier to deal pandas time-series dataframes as input and output.</p>\n", "bases": "enda.estimators.EndaEstimator"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.__init__", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.__init__", "kind": "function", "doc": "<p>Like in scikit-learn we use duck typing here, so we don't check the type of argument 'sklearn_estimator'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sklearn_estimator</span></span>)</span>"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.model", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.train", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.train", "kind": "function", "doc": "<p>Train a scikit-learn-based model from an input dataframe with features and a target column</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the input dataframe</li>\n<li><strong>target_col</strong>:  the target column name</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.predict", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.predict", "kind": "function", "doc": "<p>Predict from a scikit-learn-based trained model using an input dataframe with features</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the input dataframe</li>\n<li><strong>target_col</strong>:  the target column name</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a single-column dataframe with the predicted target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.get_model_name", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.get_model_name", "kind": "function", "doc": "<p>Return the scikit-learn model name instead of EndaSklearnEstimator</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.get_model_params", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.get_model_params", "kind": "function", "doc": "<p>Return a dict with the model name and the model hyperparameters</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.ml_backends.sklearn_estimator.EndaSklearnEstimator.get_feature_importance", "modulename": "enda.ml_backends.sklearn_estimator", "qualname": "EndaSklearnEstimator.get_feature_importance", "kind": "function", "doc": "<p>Return the feature's importance once a model has been trained.\nThis function only work if the wrapped scikit model is a linear model or a tree model.\nIn the case it's a linear model, it returns the coefficients of the fit, standardized using the standard\ndeviation of the input features (it's coherent with H2O).\nIf it's a tree, the feature importance is directly calculated by the algorithm.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a series that contain the percentage of importance for each variable</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_predictor", "modulename": "enda.power_predictor", "kind": "module", "doc": "<p>A class that handles day-ahead power prediction</p>\n"}, {"fullname": "enda.power_predictor.PowerPredictor", "modulename": "enda.power_predictor", "qualname": "PowerPredictor", "kind": "class", "doc": "<p>This class handles the day-ahead power prediction.\nIt accesses the train() and predict() methods of an EndaEstimator object.\nWe have the possibility to apply a standard power plant method\nconsidering all observations to be occurrences of the same theoretical plant\nunder different conditions (e.g. meteo, or installed kw).\nThis is applied for solar and wind plants notably.\nWe also have the possibility to treat each plant independently. Even if\nthis is less interesting when applying a usual AI algorithm, this option\nis typically used with a naive estimator for plants along the run of rivers.\nFor these plants, we simply recopy the most recent information available.</p>\n"}, {"fullname": "enda.power_predictor.PowerPredictor.__init__", "modulename": "enda.power_predictor", "qualname": "PowerPredictor.__init__", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>standard_plant</strong>:  boolean that indicates if we want to use a\nstandard plant approach, merging all observations over the plant\nportfolio.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">standard_plant</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "enda.power_predictor.PowerPredictor.standard_plant", "modulename": "enda.power_predictor", "qualname": "PowerPredictor.standard_plant", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.power_predictor.PowerPredictor.prod_estimators", "modulename": "enda.power_predictor", "qualname": "PowerPredictor.prod_estimators", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.power_predictor.PowerPredictor.train", "modulename": "enda.power_predictor", "qualname": "PowerPredictor.train", "kind": "function", "doc": "<p>We provide to this function an EndaEstimator, a training dataframe (two-levels\nmulti-indexed), and the target column.</p>\n\n<p>To train the estimator, we have two options. In the first case, we merge all the\nobservations for all the plants, and consider them to be simple realizations\nof the same single power plant with different characteristics ; that's the standard\npower plant model, used notably for wind and solar stations.\nThe second option is used for power plants along river, for which no IA is required.\nIt is a naive recopy estimator which is used.</p>\n\n<p>The training sets self.prod_estimators as a dictionary of stations ID - estimator\nIn case of a standard plant approach, the returned dictionary has a single entry,\ncalled \"standard_plant\", which becomes a reserved ID.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the training two-levels multi-indexed dataframe</li>\n<li><strong>estimator</strong>:  an EndaEstimator that will serve as a canvas to create other\nestimators of the same type that will be trained over each plant or over\nall of them in case of non-standard plant.</li>\n<li><strong>target_col</strong>:  the target column</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">estimator</span><span class=\"p\">:</span> <span class=\"n\">enda</span><span class=\"o\">.</span><span class=\"n\">estimators</span><span class=\"o\">.</span><span class=\"n\">EndaEstimator</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.power_predictor.PowerPredictor.predict", "modulename": "enda.power_predictor", "qualname": "PowerPredictor.predict", "kind": "function", "doc": "<p>Predict target_column values once train() has been called.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  the forecast two-levels multi-indexed dataframe</li>\n<li><strong>target_col</strong>:  the target column</li>\n<li><strong>is_positive</strong>:  If True, will set negative predicted values to 0</li>\n<li><strong>is_normally_clamped</strong>:  If True, will set negative predicted values to 0, and values higher than 1 to 1</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the two-levels dataframe with the predicted target only.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">is_positive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">is_normally_clamped</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations", "modulename": "enda.power_stations", "kind": "module", "doc": "<p>This module contains functions to handle power stations data</p>\n"}, {"fullname": "enda.power_stations.PowerStations", "modulename": "enda.power_stations", "qualname": "PowerStations", "kind": "class", "doc": "<p>A class to help handle power_stations data.</p>\n\n<p>Columns [time, id] are required (names can differ), and with dtype=datetime64 (tz-naive).\nOther columns describe power_station characteristics (used as features).</p>\n\n<p>All functions are meant to handle a set of station datapoints, that are considered as\nrecords (samples) for the power plant algorithms.</p>\n"}, {"fullname": "enda.power_stations.PowerStations.check_stations", "modulename": "enda.power_stations", "qualname": "PowerStations.check_stations", "kind": "function", "doc": "<ul>\n<li>Checks that station_col is in the DataFrame and has no NaN</li>\n<li>Checks that there are no duplicate timestamps for a power plant.</li>\n<li>Checks that date_start is not null and that it is before date_end when present</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The DataFrame to check</li>\n<li><strong>station_col</strong>:  The name of the plant identifier column</li>\n<li><strong>date_start_col</strong>:  The name of the column containing contracts start dates</li>\n<li><strong>date_end_exclusive_col</strong>:  The name of the column containing contracts exclusive end dates</li>\n<li><strong>is_naive</strong>:  Whether date_start_col and date_end_exclusive_col are supposed to contain na\u00efve Timestamps\n(raises an error if it doesn't match)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">station_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">is_naive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.get_stations_daily", "modulename": "enda.power_stations", "qualname": "PowerStations.get_stations_daily", "kind": "function", "doc": "<p>This function creates a daily dataframe from a power station contracts dataframe.\nIt checks the provided dataframe is consistent (dates)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>stations</strong>:  The DataFrame containing station information</li>\n<li><strong>station_col</strong>:  The column containing station name</li>\n<li><strong>date_start_col</strong>:  The column containing start date information</li>\n<li><strong>date_end_exclusive_col</strong>:  The column containing exclusive end date information</li>\n<li><strong>max_date_exclusive</strong>:  A Timestamp indicating the maximum date until which to keep data. This is\nmainly useful if you have contracts with no specified end date, as they will not be taken into account by\ndefault.</li>\n<li><strong>drop_gaps</strong>:  if True, will drop daily values that are gaps within the range of input contracts.\nBy default, these days are kept in the index with 0 as values\n(For example, if we have a station with a first contract from 2023-01-01 to 2023-02-01 and a second\ncontract from 2023-03-01 to 2023-06-01, the period from 2023-02-01 to 2023-03-01 will be kept by default\nwith 0s for all values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame with daily station information</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">stations</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">station_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;station&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_start&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;date_end_exclusive&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_date_exclusive</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">drop_gaps</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.get_stations_between_dates", "modulename": "enda.power_stations", "qualname": "PowerStations.get_stations_between_dates", "kind": "function", "doc": "<p>Adds or removes dates if needed.</p>\n\n<p>If additional dates needed at the end, copy the data of the last date into the additional dates</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>stations</strong>:  the dataframe with the stations. It must be a MultiIndex DataFrame,\nwhose second order index is a pandas.DatetimeIndex with frequency.</li>\n<li><strong>start_datetime</strong>:  the start date column, it is the same for all stations</li>\n<li><strong>end_datetime_exclusive</strong>:  the end date (exclusive)</li>\n<li><strong>freq: The frequency of the DataFrame (ex</strong>:  '30min'). If not specified, the function will try to infer it</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a station portfolio with characteristics between date_start and date_end.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">stations</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_datetime</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">end_datetime_exclusive</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.get_outages_from_file", "modulename": "enda.power_stations", "qualname": "PowerStations.get_outages_from_file", "kind": "function", "doc": "<p>Reads outages from a file. This will convert start and end date columns into dtype=datetime64 (tz-naive) and\ncheck that pct_outages_col is present in the DataFrame if specified, with values between 0 and 100 when not None</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  where the source file is located.</li>\n<li><strong>time_start_col</strong>:  the name of the outage time start column.</li>\n<li><strong>time_end_exclusive_col</strong>:  the name of the outage time end column, end date is exclusive.</li>\n<li><strong>tzinfo</strong>:  The time zone of the data we read</li>\n<li><strong>pct_outages_col</strong>:  The percentage of unavailability of the power plant (100 means complete shutdown).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a pandas.DataFrame with an outage on each row.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time_start&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">time_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time_end_exclusive&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tzinfo</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Europe/Paris&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">pct_outages_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.read_outages_from_file", "modulename": "enda.power_stations", "qualname": "PowerStations.read_outages_from_file", "kind": "function", "doc": "<p>Reads outages from a file and checks that the resulting DataFrame is coherent. This will convert start and end\ndate columns into dtype=datetime64 (tz-naive)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  where the source file is located.</li>\n<li><strong>station_col</strong>:  the name of the column containing stations names</li>\n<li><strong>time_start_col</strong>:  the name of the outage time start column.</li>\n<li><strong>time_end_exclusive_col</strong>:  the name of the outage time end column, end date is exclusive.</li>\n<li><strong>tzinfo</strong>:  The time zone of the data we read</li>\n<li><strong>pct_outages_col</strong>:  The percentage of unavailability of the power plant (100 means complete shutdown).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a pandas.DataFrame with an outage on each row.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">station_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;station&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">time_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time_start&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">time_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time_end_exclusive&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tzinfo</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Europe/Paris&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">pct_outages_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.integrate_availability_from_outages", "modulename": "enda.power_stations", "qualname": "PowerStations.integrate_availability_from_outages", "kind": "function", "doc": "<p>This function starts from a multi-indexed dataframe with stations-timeseries.\nIt takes another non-indexed dataframe containing the detail of the shutdowns\nand outages for the stations.\nIt integrates to the station-timeseries data an extra column that describe the\navailability of the stations.</p>\n\n<p>Conditions:</p>\n\n<ul>\n<li>The stations ID column must be present in both dataframes.</li>\n<li>df_stations must have a frequency. This condition is not strictly necessary\nto integrate outages a priori, but in our applications, it's almost always the case.</li>\n<li>df_outages must have time_start/time_end fields (the length of the shutdown).</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df_stations</strong>:  The DataFrame which contains the stations features as timeseries</li>\n<li><strong>df_outages</strong>:  The non-indexed outages DataFrame</li>\n<li><strong>station_col</strong>:  The column containing the station identifier</li>\n<li><strong>time_start_col</strong>:  The column containing the start time of the outage</li>\n<li><strong>time_end_exclusive_col</strong>:  The column containing the exclusive end time of the outage</li>\n<li><strong>pct_outages_col</strong>:  The column containing the information of outage impact on capacity.\nIf a null value is given, it is assumed the power plant is simply shutdown.</li>\n<li><strong>availability_col</strong>:  The name of the availability column in the new DataFrame</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df_stations</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">df_outages</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">station_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pct_outages_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">availability_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.reset_installed_capacity", "modulename": "enda.power_stations", "qualname": "PowerStations.reset_installed_capacity", "kind": "function", "doc": "<p>This function is meant to reset the installed capacity of a station using\na helper column. The helper column stores number between 0 and 1 detailing\nthe availability of the station.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The dataframe to be changed.</li>\n<li><strong>installed_capacity_kw</strong>:  The column of df that contains the installed_capacity in kW</li>\n<li><strong>stations_availability</strong>:  The name of the helper column used to compute installed capacity.\nValues should be between 0 and 1, 0 meaning a shutdown and 1 meaning full installed capacity available</li>\n<li><strong>drop_availability</strong>:  boolean flag which indicates whether the availability\ncolumn shall be dropped.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The DataFrame with corrected installed capacity</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">installed_capacity_kw</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">stations_availability</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">drop_availability</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.integrate_outages", "modulename": "enda.power_stations", "qualname": "PowerStations.integrate_outages", "kind": "function", "doc": "<p>This function makes successive calls to integrate_availability_from_outages()\nand to reset_installed_capacity().</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df_stations</strong>:  The Dataframe which contains the stations features as timeseries</li>\n<li><strong>df_outages</strong>:  The DataFrame containing outages information</li>\n<li><strong>station_col</strong>:  The column containing the station identifier</li>\n<li><strong>time_start_col</strong>:  The column containing the start time of the outage</li>\n<li><strong>time_end_exclusive_col</strong>:  The column containing the exclusive end time of the outage</li>\n<li><strong>installed_capacity_col</strong>:  The column containing the installed capacity in kW</li>\n<li><strong>pct_outages_col</strong>:  The column containing the information of outage impact on capacity</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The DataFrame with corrected installed capacity</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df_stations</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">df_outages</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">station_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">installed_capacity_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pct_outages_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.compute_load_factor", "modulename": "enda.power_stations", "qualname": "PowerStations.compute_load_factor", "kind": "function", "doc": "<p>This function computes the load_factor, which is the target column of most\nmethods implemented for the power stations production prediction</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input DataFrame for computing load factor</li>\n<li><strong>installed_capacity_kw</strong>:  The column that contains the installed_capacity in kW</li>\n<li><strong>power_kw</strong>:  The column that contains the power (in kW)</li>\n<li><strong>load_factor_col</strong>:  The name of the computed load factor column</li>\n<li><strong>drop_power_kw</strong>:  A boolean flag which indicates whether the power\ncolumn shall be dropped.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">installed_capacity_kw</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">power_kw</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">load_factor_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;load_factor&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">drop_power_kw</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.compute_power_kw_from_load_factor", "modulename": "enda.power_stations", "qualname": "PowerStations.compute_power_kw_from_load_factor", "kind": "function", "doc": "<p>This function computes the power (in kW) from the computed load_factor.\nIt is the inverse transform of compute_load_factor()</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The input DataFrame for computing power</li>\n<li><strong>installed_capacity_kw</strong>:  The column that contains the installed_capacity in kW</li>\n<li><strong>load_factor</strong>:  The column which contains the load factor</li>\n<li><strong>power_kw_col</strong>:  The name of the computed power column</li>\n<li><strong>drop_load_factor</strong>:  A boolean flag which indicates whether the load factor\ncolumn shall be dropped.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">installed_capacity_kw</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">load_factor</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">power_kw_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;power_kw&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">drop_load_factor</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.power_stations.PowerStations.clip_column", "modulename": "enda.power_stations", "qualname": "PowerStations.clip_column", "kind": "function", "doc": "<p>Checks that values in the indicated colname are between the two specified bounds (bounds included).\nIf not, replaces the excessive values with the associated bounds</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  The DataFrame to use the function on</li>\n<li><strong>column_name</strong>:  The column to check and clip</li>\n<li><strong>lower_bound</strong>:  If not None, the lower bound that we can't go below of.</li>\n<li><strong>upper_bound</strong>:  If not None, the upper bound that we can't go above of. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dataframe where all the values in the specified columns are between the two bounds. If we find\n      excessive values, we set them equal to the closer bound</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">column_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lower_bound</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring", "modulename": "enda.scoring", "kind": "module", "doc": "<p>This module contains methods to evaluate the performance of predictions</p>\n"}, {"fullname": "enda.scoring.wape", "modulename": "enda.scoring", "qualname": "wape", "kind": "function", "doc": "<p>Weighted average percentage error (WAPE or wMAPE)</p>\n\n<p>Based on code from sklearn.metrics.mean_absolute_percentage_error.\nNote here that the output is not a percentage in the range [0, 100].</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>y_true : array-like of shape (n_samples,) or (n_samples, n_outputs)\n    Ground truth (correct) target values.</p>\n\n<p>y_pred : array-like of shape (n_samples,) or (n_samples, n_outputs)\n    Estimated target values.</p>\n\n<p>sample_weight : array-like of shape (n_samples,), default=None\n    Sample weights.</p>\n\n<p>multioutput : {'raw_values', 'uniform_average'} or array-like\n    Defines aggregating of multiple output values.\n    Array-like value defines weights used to average errors.\n    If input is list then the shape must be (n_outputs,).</p>\n\n<pre><code>'raw_values' :\n    Returns a full set of errors in case of multioutput input.\n\n'uniform_average' :\n    Errors of all outputs are averaged with uniform weight.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>loss : float or ndarray of floats\n    If multioutput is 'raw_values', then mean absolute percentage error\n    is returned for each output separately.\n    If multioutput is 'uniform_average' or a ndarray of weights, then the\n    weighted average of all output errors is returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y_true</span>, </span><span class=\"param\"><span class=\"n\">y_pred</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">sample_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">multioutput</span><span class=\"o\">=</span><span class=\"s1\">&#39;uniform_average&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.METRICS_FUNCTION_DICT", "modulename": "enda.scoring", "qualname": "METRICS_FUNCTION_DICT", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;max_error&#x27;: &lt;function max_error&gt;, &#x27;mae&#x27;: &lt;function mean_absolute_error&gt;, &#x27;mape&#x27;: &lt;function mean_absolute_percentage_error&gt;, &#x27;mse&#x27;: &lt;function mean_squared_error&gt;, &#x27;rmse&#x27;: &lt;function _root_mean_squared_error&gt;, &#x27;r2&#x27;: &lt;function r2_score&gt;, &#x27;wape&#x27;: &lt;function wape&gt;}"}, {"fullname": "enda.scoring.Scoring", "modulename": "enda.scoring", "qualname": "Scoring", "kind": "class", "doc": "<p>A class to help scoring algorithms\npredictions_df must include the 'target' column and the predictions in all other columns</p>\n"}, {"fullname": "enda.scoring.Scoring.__init__", "modulename": "enda.scoring", "qualname": "Scoring.__init__", "kind": "function", "doc": "<p>Initialize the scoring object</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predictions_df</strong>:  A DataFrame containing the predictions to be scored in columns, as well as a column with the target. The index must be a datetime-index.</li>\n<li><strong>target</strong>:  The name of the column which contains the target values against which predictions are scored.</li>\n<li><strong>normalizing_col</strong>:  Optional, a normalizing column for computing normalized absolute error</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">predictions_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">normalizing_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "enda.scoring.Scoring.predictions_df", "modulename": "enda.scoring", "qualname": "Scoring.predictions_df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.scoring.Scoring.target", "modulename": "enda.scoring", "qualname": "Scoring.target", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.scoring.Scoring.normalizing_col", "modulename": "enda.scoring", "qualname": "Scoring.normalizing_col", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.scoring.Scoring.error_df", "modulename": "enda.scoring", "qualname": "Scoring.error_df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.scoring.Scoring.pct_error_df", "modulename": "enda.scoring", "qualname": "Scoring.pct_error_df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "enda.scoring.Scoring.error", "modulename": "enda.scoring", "qualname": "Scoring.error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the error between the prediction and the target (prediction - target)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.mean_error", "modulename": "enda.scoring", "qualname": "Scoring.mean_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A Series of the mean error between each algorithm and the target, with algorithm names as the index</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.absolute_error", "modulename": "enda.scoring", "qualname": "Scoring.absolute_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the absolute error between the prediction and the target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.absolute_error_statistics", "modulename": "enda.scoring", "qualname": "Scoring.absolute_error_statistics", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame describing the statistics of the absolute error between target and predictions,\n      such as mean, std and some quantiles</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.mean_absolute_error", "modulename": "enda.scoring", "qualname": "Scoring.mean_absolute_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A Series of the mean absolute error between each algorithm and the target,\n      with algorithm names as the index</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.mean_absolute_error_by_month", "modulename": "enda.scoring", "qualname": "Scoring.mean_absolute_error_by_month", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the mean absolute error grouped by month</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.percentage_error", "modulename": "enda.scoring", "qualname": "Scoring.percentage_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the relative error in percentage between prediction and target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.absolute_percentage_error", "modulename": "enda.scoring", "qualname": "Scoring.absolute_percentage_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the absolute relative error in percentage between prediction and target</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.absolute_percentage_error_statistics", "modulename": "enda.scoring", "qualname": "Scoring.absolute_percentage_error_statistics", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame describing the statistics of the absolute relative error in percentage between target\n      and predictions, such as mean, std and some quantiles</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.mean_absolute_percentage_error", "modulename": "enda.scoring", "qualname": "Scoring.mean_absolute_percentage_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A Series of the mean absolute percentage error between each algorithm and the target,\n      with algorithm names as the index</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.mean_absolute_percentage_error_by_month", "modulename": "enda.scoring", "qualname": "Scoring.mean_absolute_percentage_error_by_month", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the mean absolute percentage error grouped by month</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.normalized_absolute_error", "modulename": "enda.scoring", "qualname": "Scoring.normalized_absolute_error", "kind": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame of the absolute error between the predictions and the target, normalized by the\n      normalized_col (if it isn't defined, will raise en error)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.scoring.Scoring.compute_loss", "modulename": "enda.scoring", "qualname": "Scoring.compute_loss", "kind": "function", "doc": "<p>Compute the loss (i.e. the score) between a model prediction and the actual data</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicted_df</strong>:  the result of the prediction</li>\n<li><strong>actual_df</strong>:  the actual target data</li>\n<li><strong>scores</strong>:  the statistics to consider. Either 'max_error', 'mae', 'rmse', 'r2', 'mape', 'mse', 'wape'.\nDefaults to 'rmse'.\nIf a list is given, the code detects the statistics to use itself.\nThe score to use can be customized by the user with a dict (name, method).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a series that contains for each statistics the score of the model on the training set</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">predicted_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">actual_df</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">scores</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.timeseries", "modulename": "enda.timeseries", "kind": "module", "doc": "<p>This module is deprecated and has been moved in tools.timeseries</p>\n"}, {"fullname": "enda.timezone_utils", "modulename": "enda.timezone_utils", "kind": "module", "doc": "<p>This module is deprecated and has been moved in tools.timezone_utils</p>\n"}, {"fullname": "enda.tools", "modulename": "enda.tools", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "enda.tools.decorators", "modulename": "enda.tools.decorators", "kind": "module", "doc": "<p>This module contains various utility functions to be used as decorators</p>\n"}, {"fullname": "enda.tools.decorators.handle_multiindex", "modulename": "enda.tools.decorators", "qualname": "handle_multiindex", "kind": "function", "doc": "<p>This function is meant to be used as a decorator. It is a wrapper around functions defined\nfor a single-indexed dataframe so that they also work for multi-indexed dataframes.\nThe wrapped function will be applied to all single-indexed last-level dataframes\nwhich constitute the multi-index dataframe</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arg_name</strong>:  name of the dataframe in the wrapped function signature.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.decorators.handle_series_as_datetimeindex", "modulename": "enda.tools.decorators", "qualname": "handle_series_as_datetimeindex", "kind": "function", "doc": "<p>This function is meant to be used as a decorator over functions which process timeseries\ngiven as datetimeIndex, so that they can process time_series given as pd.Series too.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arg_name</strong>:  name of the datetimeindex in the wrapped function signature.</li>\n<li><strong>return_input_type</strong>:  boolean, if true, for a decorated function that returns a datetime index,\nit will return a datetimeindex if a datetimeindex is passed, but a series\nif a series is passed.\nIf False, it will return the object the function would if un-decorated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg_name</span>, </span><span class=\"param\"><span class=\"n\">return_input_type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.decorators.warning_deprecated_name", "modulename": "enda.tools.decorators", "qualname": "warning_deprecated_name", "kind": "function", "doc": "<p>This decorator with a parameter is meant to be used to issue a specific warning, namely that a function\nhas been renamed, or moved in a new namespace. This is useful for classes that changed named, or will be deleted</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>namespace_name</strong>:  the namespace that contains the function. Might be the one to replace.</li>\n<li><strong>new_namespace_name</strong>:  the new namespace that contains the function</li>\n<li><strong>new_function_name</strong>:  the new name of the function</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">namespace_name</span>, </span><span class=\"param\"><span class=\"n\">new_namespace_name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">new_function_name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.portfolio_tools", "modulename": "enda.tools.portfolio_tools", "kind": "module", "doc": "<p>This module contains utility functions for transforming portfolio data</p>\n"}, {"fullname": "enda.tools.portfolio_tools.PortfolioTools", "modulename": "enda.tools.portfolio_tools", "qualname": "PortfolioTools", "kind": "class", "doc": "<p>This class contains utility methods used on portfolio DataFrames (typically DataFrames where each row\nrepresents a contract with either clients or producers</p>\n"}, {"fullname": "enda.tools.portfolio_tools.PortfolioTools.portfolio_to_events", "modulename": "enda.tools.portfolio_tools", "qualname": "PortfolioTools.portfolio_to_events", "kind": "function", "doc": "<p>Converts a portfolio DataFrame where each line has a start and an and date to an event DataFrame, where\neach line is a start or end of contract event, except if the end date is null</p>\n\n<p>Given portfolio_df:\nstation         start_date      excl_end_date     value_col\nstation1        2023-01-01      2024-01-01        10\nstation2        2023-06-01      None              30</p>\n\n<p>_portfolio_to_events(portfolio_df, 'start_date', 'excl_end_date'):\nevent_type      event_date      station     value_col\nstart           2023-01-01      station1    1O\nstart           2023-06-01      station2    30\nend             2024-01-01      station1    10</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>portfolio_df</strong>:  The portfolio DataFrame to modify</li>\n<li><strong>date_start_col</strong>:  The column containing contracts start dates</li>\n<li><strong>date_end_exclusive_col</strong>:  The column containing contracts exclusive end date (can be null)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A DataFrame with one row per start/end event, order by event date and event type</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">portfolio_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">date_start_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date_end_exclusive_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.portfolio_tools.PortfolioTools.get_portfolio_between_dates", "modulename": "enda.tools.portfolio_tools", "qualname": "PortfolioTools.get_portfolio_between_dates", "kind": "function", "doc": "<p>Keeps portfolio data between the specified dates.\nIf the first date in portfolio is after start_datetime, we add missing dates with 0 as value.\nIf the last date in portfolio is before end_datetime_exclusive, we forward fill the last present values\nuntil end_datetime_exclusive</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>portfolio_df</strong>:  The portfolio DataFrame. It must have a pd.DatetimeIndex with a frequency</li>\n<li><strong>start_datetime</strong>:  The start datetime from which to keep the portfolio</li>\n<li><strong>end_datetime_exclusive</strong>:  The exclusive end datetime until which to keep the portfolio</li>\n<li><strong>freq: The frequency of the DataFrame (ex</strong>:  '30min'). If not specified, the function will try to infer it</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A portfolio DataFrame with values between specified dates</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">portfolio_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">start_datetime</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">end_datetime_exclusive</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample", "modulename": "enda.tools.resample", "kind": "module", "doc": "<p>This module contains functions for resampling timeseries</p>\n"}, {"fullname": "enda.tools.resample.Resample", "modulename": "enda.tools.resample", "qualname": "Resample", "kind": "class", "doc": "<p>This class contains methods to resample (up or down) timeseries DataFrames</p>\n"}, {"fullname": "enda.tools.resample.Resample.downsample", "modulename": "enda.tools.resample", "qualname": "Resample.downsample", "kind": "function", "doc": "<p>Downsample a datetime-indexed pd.DataFrame to a provided frequency using one or several aggregation functions.\nThe provided frequency must be greater than the original one in the dataframe index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  the dataframe with a datetime-like index</li>\n<li><strong>freq</strong>:  the aimed frequency. If given as a pd.Timedelta, it must be convertible to freq string</li>\n<li><strong>groupby</strong>:  If a list of columns is provided, the DataFrame will be grouped by specified columns\nbefore resampling</li>\n<li><strong>agg_functions</strong>:  aggregate functions used for resampling passed to aggregate().\nIf a dict is provided, it must indicate an agg function for each column of the dataframe\nIf a string is provided, it will be used for all columns of the dataframe.\nDefault is 'mean' for all columns</li>\n<li><strong>origin</strong>:  the timestamp on which to adjust the grouping.\nDefault is 'start_day', i.e. origin is the first day at midnight of the timeseries\nOther options are 'epoch', 'start', 'end', 'end_day'. For more details, see\n<a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html\">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html</a></li>\n<li><strong>is_original_frequency_unique</strong>:  boolean, if True, ensure there's no missing value, no extra-point,\nand a single well-defined frequency in the original dataframe</li>\n<li><strong>index_name</strong>:  a name to give to the new index. For instance going from 'date' to 'time'.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">agg_functions</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mean&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;start_day&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">is_original_frequency_unique</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample.Resample.upsample_and_divide_evenly", "modulename": "enda.tools.resample", "qualname": "Resample.upsample_and_divide_evenly", "kind": "function", "doc": "<p>Upsample a datetime-indexed pd.DataFrame to a provided frequency and divide the values so that the sum\nof columns remains the same :\n{2023-01-01 00:00:00 : 50, 2023-01-01 00:30:00: 40} with 15 minutes resampling should give\n{2023-01-01 00:00:00 : 25, 2023-01-01 00:15:00 : 25,\n 2023-01-01 00:30:00 : 20, 2023-01-01 00:45:00 : 20}\nThis is intended for columns with numerical values that vary when changing frequency (such as energy and cost,\nbut not power)\nNote there is a forward-filling of the last record before dividing, because it's the only behaviour that makes\nsense.\nThe provided frequency must be lower than the original one in the dataframe index. Does not work if frequency\nin the original DataFrame isn't unique (for example : monthly values, as number of days in a month varies)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  the dataframe with a datetime-like index</li>\n<li><strong>freq</strong>:  the aimed frequency. If given as string, it must be convertible to pd.Timedelta, eg '1D' or '1H'</li>\n<li><strong>index_name</strong>:  a name to give to the new index. For instance going from 'date' to 'time'.</li>\n<li><strong>tz_info</strong>:  the target time zone in case the index is resampled in another timezone / or if we want to\ngo from a non-localized timestamp (e.g. dates) to a localized one (e.g. date-times)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the upsampled timeseries dataframe</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample.Resample.upsample_monthly_data_and_divide_evenly", "modulename": "enda.tools.resample", "qualname": "Resample.upsample_monthly_data_and_divide_evenly", "kind": "function", "doc": "<h1 id=\"todo-integrate-to-the-previous-function\">@ TODO integrate to the previous function ?</h1>\n\n<p>Upsample a monthly datetime-indexed pd.DataFrame to a provided frequency and averages the values so that the sum\nof columns remains the same :\n{2023-01-01 00:00:00 : 50, 2023-01-01 00:30:00: 40} with 15 minutes resampling should give\n{2023-01-01 00:00:00 : 25, 2023-01-01 00:15:00 : 25,\n 2023-01-01 00:30:00 : 20, 2023-01-01 00:45:00 : 20}\nThis is intended for columns with numerical values that vary when changing frequency (such as energy and cost,\nbut not power)\nThe provided frequency must be lower than the original one in the dataframe index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  the dataframe with a datetime-like index</li>\n<li><strong>freq</strong>:  the aimed frequency. If given as string, it must be convertible to pd.Timedelta, eg '1D' or '1H'</li>\n<li><strong>tz_info</strong>:  the target time zone in case the index is resampled in another timezone / or if we want to\ngo from a non-localized timestamp (eg. dates) to a localized one (e.g. date-times)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the upsampled timeseries dataframe</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample.Resample.upsample_and_interpolate", "modulename": "enda.tools.resample", "qualname": "Resample.upsample_and_interpolate", "kind": "function", "doc": "<p>Upsample a datetime-indexed dataframe, and interpolate the columns data according to an interpolating method</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  the dataframe to resample</li>\n<li><strong>freq</strong>:  the target frequency (timedelta) e.g. 'H', '30min', '15min', etc.</li>\n<li><strong>method</strong>:  how are data interpolated between two consecutive dates (e.g. 'ffill', 'linear', etc.)</li>\n<li><strong>forward_fill</strong>:  If True, the upsampling is performed for the last element of the datetimeindex</li>\n<li><strong>is_original_frequency_unique</strong>:  check whether the frequency is unique in the initial dataframe</li>\n<li><strong>index_name</strong>:  a name to give to the new index. For instance going from 'date' to 'time'.</li>\n<li><strong>tz_info</strong>:  the target time zone in case the index is resampled in another timezone / or if we want to\ngo from a non-localized timestamp (e.g. dates) to a localized one (e.g. date-times)</li>\n<li><strong>expected_initial_freq</strong>:  the expected initial frequency of the dataframe. This serves to check the\nresampling, and for the particular case of one-row dataframe which must be forward-filled.</li>\n<li><strong>**kwargs</strong>:  arguments to pass to pandas.interpolate()</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the upsampled timeseries dataframe</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">forward_fill</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">is_original_frequency_unique</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_initial_freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample.Resample.equal_sample_fillna", "modulename": "enda.tools.resample", "qualname": "Resample.equal_sample_fillna", "kind": "function", "doc": "<p>Fill missing values in a datetime-indexed pd.DataFrame with a frequency.\nTwo options are possible to fill the missing values:\n    - 'fill_value' is used to fill with the same value (can be NaN, default behavior if set to None)\n      all missing timestamp, calling Resampler.asfreq()\n    - 'method_filling' fills missing values calling Resampler.fillna() if method_filling\n      is in {\u2018pad\u2019, \u2018backfill\u2019, \u2018ffill\u2019, \u2018bfill\u2019, \u2018nearest\u2019}</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  the dataframe with a datetime-like index</li>\n<li><strong>fill_value</strong>:  value to fill all missing values.</li>\n<li><strong>method_filling</strong>:  the method used to fill nan values.</li>\n<li><strong>safe_run</strong>:  boolean, if True, check there is no duplicates nor extra_periods\nthat the resampling could delete</li>\n<li><strong>expected_freq</strong>:  if known, the expected freq of the dataframe (and resulting)</li>\n<li><strong>start_time</strong>:  the index beginning. If None, it's the min of the dataframe index</li>\n<li><strong>excl_end_time</strong>:  the index excl end date. If None, it's the min of the dataframe index</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method_filling</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">safe_run</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">start_time</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">excl_end_time</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.resample.Resample.forward_fill_final_record", "modulename": "enda.tools.resample", "qualname": "Resample.forward_fill_final_record", "kind": "function", "doc": "<p>Forward-fill the final record of a regular datetime-indexed dataframe, keeping the frequency of\nthe initial time series. This function not only add a timestamp, but resample with a forward-fill\nthe timeseries until the desired timestamp.\nNaming 'final_ts' the max of the index of the initial dataframe timeseries_df, the resulting index of the\nfinal dataframe can be determined from two manners:</p>\n\n<ul>\n<li>using the argument 'gap_timedelta' so that the new index goes until final_ts + gap_timedelta (excluded)</li>\n<li>using the argument 'excl_end_final_date' so that the new index goes until excl_end_time (excluded)\nThe resampling frequency is determined from the frequency of the initial dataframe.\nThe extra parameter 'cut_off' can be used to set up a limit not to overpass. It means the resulting index is\ntruncated to take into account the given cut-off.\nThis function is typically used in junction with upsample_*() to forward-fill the last record.</li>\n</ul>\n\n<p>Here are some examples:</p>\n\n<ol>\n<li>Given timeseries_df:\ntime_index                value\n2021-01-01 00:00:00+01:00 1\n2021-01-01 12:00:00+01:00 2\n2021-01-02 00:00:00+01:00 3</li>\n</ol>\n\n<p>forward_fill_final_record(timeseries_df, gap_timedelta='1D'):\n2021-01-01 00:00:00+01:00 1\n2021-01-01 12:00:00+01:00 2\n2021-01-02 00:00:00+01:00 3\n2021-01-02 12:00:00+01:00 3</p>\n\n<ol start=\"2\">\n<li>Given df:\ntime_index                value\n2021-01-01 19:00:00+01:00 1\n2021-01-01 20:00:00+01:00 2\n2021-01-01 21:00:00+01:00 3\n2021-01-01 22:00:00+01:00 4</li>\n</ol>\n\n<p>forward_fill_final_record(timeseries_df, gap_timedelta='3H', cut_off=None):\n2021-01-01 19:00:00+01:00 1\n2021-01-01 20:00:00+01:00 2\n2021-01-01 21:00:00+01:00 3\n2021-01-01 22:00:00+01:00 4\n2021-01-01 23:00:00+01:00 4\n2021-01-02 00:00:00+01:00 4</p>\n\n<ol start=\"3\">\n<li>Given df:\ntime_index                value\n2021-01-01 19:00:00+01:00 1\n2021-01-01 20:00:00+01:00 2\n2021-01-01 21:00:00+01:00 3\n2021-01-01 22:00:00+01:00 4</li>\n</ol>\n\n<p>forward_fill_final_record(timeseries_df, gap_timedelta='3H', cut_off='1D'):\n2021-01-01 19:00:00+01:00 1\n2021-01-01 20:00:00+01:00 2\n2021-01-01 21:00:00+01:00 3\n2021-01-01 22:00:00+01:00 4\n2021-01-01 23:00:00+01:00 4</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeseries_df</strong>:  input datetime-indexed dataframe to be forward-filled.</li>\n<li><strong>gap_timedelta</strong>:  The forward-filling is performed using this argument if provided.\nBasically, the last index is extended until last_index + gap_timedelta\nThis option is incompatible with the setting of the excl_end_time argument</li>\n<li><strong>cut_off</strong>:  a timedelta that serves as a cut-off beyond which the final record is not extended</li>\n<li><strong>excl_end_time</strong>:  The forward-filling is performed using this argument if provided.\nBasically, the last index is extended until excl_end_time - timeseries_df.index.freq\nThis option is incompatible with the setting of the gap_timedelta argument</li>\n<li><strong>freq</strong>:  The frequency to use to forward-fill. Usually, it's not given, and determined from the dataframe\nindex directly, except if the dataframe is a one-row dataframe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>datetime-indexed dataframe similar to the initial one, with the last record being forward filled\n           using the initial frequency of the dataframe index.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">timeseries_df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">gap_timedelta</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cut_off</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">excl_end_time</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries", "modulename": "enda.tools.timeseries", "kind": "module", "doc": "<p>This module contains functions to help manipulating timeseries</p>\n"}, {"fullname": "enda.tools.timeseries.TimeSeries", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries", "kind": "class", "doc": "<p>This class contains methods for manipulating timeseries</p>\n"}, {"fullname": "enda.tools.timeseries.TimeSeries.FREQ_UNIT_TO_DAYS", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.FREQ_UNIT_TO_DAYS", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;ms&#x27;: 1.1574074074074074e-08, &#x27;s&#x27;: 1.1574074074074073e-05, &#x27;S&#x27;: 1.1574074074074073e-05, &#x27;min&#x27;: 0.0006944444444444445, &#x27;MIN&#x27;: 0.0006944444444444445, &#x27;T&#x27;: 0.0006944444444444445, &#x27;H&#x27;: 0.041666666666666664, &#x27;h&#x27;: 0.041666666666666664, &#x27;D&#x27;: 1, &#x27;d&#x27;: 1, &#x27;B&#x27;: 1, &#x27;b&#x27;: 1, &#x27;W&#x27;: 7, &#x27;w&#x27;: 7, &#x27;W-SUN&#x27;: 7, &#x27;W-MON&#x27;: 7, &#x27;M&#x27;: 30.4, &#x27;MS&#x27;: 30.4, &#x27;Q&#x27;: 91, &#x27;A&#x27;: 365, &#x27;Y&#x27;: 365}"}, {"fullname": "enda.tools.timeseries.TimeSeries.FREQ_UNIT_TO_SECONDS", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.FREQ_UNIT_TO_SECONDS", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;ms&#x27;: 0.001, &#x27;s&#x27;: 1, &#x27;S&#x27;: 1, &#x27;min&#x27;: 60, &#x27;MIN&#x27;: 60, &#x27;T&#x27;: 60, &#x27;H&#x27;: 3600, &#x27;h&#x27;: 3600, &#x27;D&#x27;: 86400, &#x27;d&#x27;: 86400, &#x27;B&#x27;: 86400, &#x27;b&#x27;: 86400, &#x27;W&#x27;: 604800, &#x27;w&#x27;: 604800, &#x27;W-SUN&#x27;: 604800, &#x27;W-MON&#x27;: 604800, &#x27;M&#x27;: 2626560, &#x27;MS&#x27;: 2626560, &#x27;Q&#x27;: 7862400, &#x27;A&#x27;: 31536000, &#x27;Y&#x27;: 31536000}"}, {"fullname": "enda.tools.timeseries.TimeSeries.split_amount_and_unit_from_freq", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.split_amount_and_unit_from_freq", "kind": "function", "doc": "<p>Given a frequency as a string, such as '1D', '10min', '-3MS'\nextract the amount (e.g. 1, 10, -3) and the unit part (e.g. 'D', 'min', 'MS'), capitalized.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>freq</strong>:  the frequency</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the unit part of that frequency, and the number of units</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.is_regular_freq", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.is_regular_freq", "kind": "function", "doc": "<p>Return a boolean that indicates the frequency is something regular or not\neg 'D' 'min' are regular, 'MS', 'Y', 'Q' are not.\nFor instance, irregular frequencies cannot be turned to pd.Timedelta elements.\nNote that if the frequency is a pd.Timedelta, it is always regular</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>freq</strong>:  the frequency given as a string or a pd.Timedelta</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a boolean that indicates whether the considered frequency is 'even'</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.freq_as_approximate_nb_days", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.freq_as_approximate_nb_days", "kind": "function", "doc": "<p>Map pandas freq string to an approximate length of days.\nThis serves to compare freq strings, such as '1D', '3MS', and so on.\nIt replaces the calls to total_seconds() possibly used only with pd.Timedelta().\nNote that the computation is exact if a pd.Timedelta is given.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>freq</strong>:  the frequency as a string, such as '10min', '3MS', or a pd.Timedelta.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a sometimes approximate length of the provided frequency in days</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.freq_as_approximate_nb_seconds", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.freq_as_approximate_nb_seconds", "kind": "function", "doc": "<p>Map pandas freq string to an approximate number of seconds.\nThis serves to compare freq strings, such as '1D', '3MS', and so on.\nIt replaces the calls to total_seconds() possibly used only with pd.Timedelta().\nNote that the computation is exact if a pd.Timedelta is given.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>freq</strong>:  the frequency as a string, such as '10min', '3MS', or a pd.Timedelta.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a sometimes approximate length of the provided frequency in days</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.add_timedelta", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.add_timedelta", "kind": "function", "doc": "<p>Define how to add a timedelta according to the way it's provided (string, timedelta), regular or irregular\nabsolute length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>date</strong>:  a date, provided as a pd.Timestamp (naive or tz-aware), a date, a datetime</li>\n<li><strong>timedelta</strong>:   a timedelta, given as a freq string (e.g. '2MS') or a pd.Timedelta object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">date</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">timedelta</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.subtract_timedelta", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.subtract_timedelta", "kind": "function", "doc": "<p>Define how to subtract a timedelta according to the way it's provided (string, timedelta), regular or irregular\nabsolute length.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>date</strong>:  a date, provided as a pd.Timestamp (naive or tz-aware), a date, a datetime</li>\n<li><strong>timedelta</strong>:  a timedelta, given as a freq string (e.g. '2MS') or a pd.Timedelta object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">date</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">timedelta</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.has_nan_or_empty", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.has_nan_or_empty", "kind": "function", "doc": "<p>Check whether a datetime index has NaN or is empty</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  pd.DatetimeIndex to investigate</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_nb_records", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_nb_records", "kind": "function", "doc": "<p>Compute the number of records\n :param dti: pd.DatetimeIndex to investigate</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>skip_duplicate_timestamps</strong>:  bool that indicates if duplicates must be considered\nor not when computing the number of records</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the number of records in the time series</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">skip_duplicate_timestamps</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_gap_distribution", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_gap_distribution", "kind": "function", "doc": "<p>Find frequencies in a pd.DatetimeIndex. The function computes\nall timedelta between successive indexes, and count them. It returns an ordered\npd.Series, with the most commonly found in index 0.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  pd.DatetimeIndex to investigate</li>\n<li><strong>skip_duplicate_timestamps</strong>:  bool that indicates if duplicates must be considered\nor not when the gap distribution is considered.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a pd.Series with all frequencies found, and their cardinality.\n          eg. &gt;&gt;&gt; find_frequencies(dti)\n          #    01:00:00    1181\n          #    02:00:00     499\n          #    03:00:00     180\n          #    ....</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">skip_duplicate_timestamps</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_most_common_frequency", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_most_common_frequency", "kind": "function", "doc": "<p>Find most common frequency in pd.DatetimeIndex. If several frequencies are found, it returns the most common.\nThe function checks the index is not null,</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  pd.DatetimeIndex to investigate</li>\n<li><strong>skip_duplicate_timestamps</strong>:  if True, the function will not consider duplicate timestamps\nin the calculation.\n:return : the most common frequency found in the datetime index as a string</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">skip_duplicate_timestamps</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_duplicates", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_duplicates", "kind": "function", "doc": "<p>Check for duplicates in the timeseries</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>duplicates</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_extra_points", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_extra_points", "kind": "function", "doc": "<p>Check for extra data points in the timeseries, i.e. data points that are\noutside the expected frequency (or the most common frequency if not known) of data points.\nThis is based on the min and max of the index, which means no extra point might be found\nif min or max are the extra points (in that case, there might be missing periods!)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n<li><strong>expected_freq</strong>:  the expected freq of the datetime index if known, default None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>extra data points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_duplicates_and_extra_points", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_duplicates_and_extra_points", "kind": "function", "doc": "<p>Check for extra data points in the timeseries, i.e. data points that are duplicated and/or data points that are\noutside the expected frequency (or the most common frequency if not known) of data points.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a time_series</li>\n<li><strong>expected_freq</strong>:  the expected freq of the datetime index if known, default None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>extra data points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_missing_points", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_missing_points", "kind": "function", "doc": "<p>Check for missing periods in the time series with an expected frequency.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n<li><strong>expected_freq</strong>:  the expected freq of the datetime index if known, default None.</li>\n<li><strong>expected_start_datetime</strong>:  the expected start time of the datetime index, default None</li>\n<li><strong>expected_excl_end_datetime</strong>:  the expected exclusive end time of the datetime index, default None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>missing points as a datetime index</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_start_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_excl_end_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.collapse_to_periods", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.collapse_to_periods", "kind": "function", "doc": "<p>Given a datetime index and a frequency, it gives the list of regular periods found in the datetime index, as\na collection of tuples that contain the start time and exclusive time of the periods found. More precisely,\nif a timestamp is missing (ie if t is present but t + freq is missing), a new period is defined (t\nbecomes the end time of the current period, and the next timestamp found after t defines the beginning of a new\nperiod).\nDuplicates are dropped in the operation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n<li><strong>freq</strong>:  the freq of the datetime index used to find missing periods.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of tuples that contain the regular periods in the datetime index (defined as the start and\n  inclusive end times of the period).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;]</span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_missing_periods", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_missing_periods", "kind": "function", "doc": "<p>Find missing periods in a datetimeIndex. It finds all missing points, and collapse them\nin periods</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n<li><strong>expected_freq</strong>:  the expected freq of the datetime index if known, default None.</li>\n<li><strong>expected_start_datetime</strong>:  the expected start time of the datetime index, default None</li>\n<li><strong>expected_excl_end_datetime</strong>:  the expected exclusive end time of the datetime index, default None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>missing periods as a list of tuples of start and end times of the missing periods.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_start_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_excl_end_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.has_single_frequency", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.has_single_frequency", "kind": "function", "doc": "<p>Return True if the provided datetime index has a single frequency, i.e.\ndoes not have missing periods, extra points, nor change of frequency</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  pd.DatetimeIndex to investigate</li>\n<li><strong>variable_duration_freq_included</strong>:  'Frequency' may have a double meaning, whether fixed-time frequencies\nare considered or not. For instance, a frequency of one month leads to\nintervals with different absolute length (in terms of days, and seconds).\nSetting True means the datetimeindex is inspected with absolute duration\nin mind. It is useful when we expect:\n<ul>\n<li>an x-min difference between timestamps</li>\n<li>an x-day difference between dates</li>\n</ul></li>\n<li><strong>skip_duplicate_timestamps</strong>:  If True, the function will not consider duplicate timestamps</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>True if the data has a clean single frequency defined.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">variable_duration_freq_included</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">skip_duplicate_timestamps</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.align_timezone", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.align_timezone", "kind": "function", "doc": "<p>Sometimes a time series is of pandas type \"object\" just because the time-zone information\nis not well-read initially. Such a series can't be translated to a pd.DatetimeIndex.\nThis function makes sure the time zone information of the input series is set to the input\ntz_info for each row and also for the series.</p>\n\n<p>Example :\ntime_series = a time_series with some times at timezone +01:00 (French winter time)\n              and others at timezone +02:00 (French summer)\n              So its pandas dtype is \"object\"\ntz = pytz.timezone(\"Europe/Paris\")</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>time_series</strong>:  a series with tz-aware date-times. If a datetime-index is passed, the function\nprocess it</li>\n<li><strong>tzinfo</strong>:  a str or a datetime.tzinfo</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a DatetimeIndex of dtype: datetime[ns, tzinfo]</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">time_series</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>,</span><span class=\"param\">\t<span class=\"n\">tzinfo</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">timezone</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.find_missing_and_extra_periods", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.find_missing_and_extra_periods", "kind": "function", "doc": "<p>Check for missing and extra data points</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a series of type DatetimeIndex, in ascending order and without duplicates or NaNs</li>\n<li><strong>expected_freq</strong>:  pandas formatted frequency. If None is given, will infer the frequency, taking the\nmost common gap between 2 consecutive points.</li>\n<li><strong>expected_start_datetime</strong>:  a pandas.Datetime, if None is given, will take dti[0]</li>\n<li><strong>expected_end_datetime</strong>:  a pandas.Datetime, if None is given, will take dti[-1]</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Missing and extra data points collapsed in periods</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">dti</span>,</span><span class=\"param\">\t<span class=\"n\">expected_freq</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_start_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">expected_end_datetime</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.collapse_dt_series_into_periods", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.collapse_dt_series_into_periods", "kind": "function", "doc": "<p>Given a datetime index and a frequency, it gives the list of regular periods found in the datetime index, as\na collection of tuples that contain the start time and exclusive time of the periods found. More precisely,\nif a timestamp is missing (ie if t is present but t + freq is missing), a new period is defined (t\nbecomes the end time of the current period, and the next timestamp found after t defines the beginning of a new\nperiod).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dti</strong>:  a datetime index, without NaN</li>\n<li><strong>freq</strong>:  the freq of the datetime index used to find missing periods.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a list of tuples that contain the regular periods in the datetime index (defined as the start and\n  inclusive end times of the period).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">dti</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;]</span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.get_timeseries_frequency", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.get_timeseries_frequency", "kind": "function", "doc": "<p>Retrieve the frequency of a pandas dataframe's index.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.interpolate_freq_to_sub_freq_data", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.interpolate_freq_to_sub_freq_data", "kind": "function", "doc": "<p>Interpolate dataframe data on a smaller frequency than the one initially defined\nin the dataframe\nThe original index of the data must have a well-defined frequency, i.e. it must be\nable to retrieve its frequency with inferred_freq</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  pd.DataFrame</li>\n<li><strong>freq</strong>:  a frequency e.g. 'H', '30min', '15min', etc.</li>\n<li><strong>tz</strong>:  the target time zone.</li>\n<li><strong>index_name</strong>:  name to give to the new index. Usually going from 'date' to 'time'.</li>\n<li><strong>method</strong>:  how are data interpolated between two consecutive dates (e.g. 'ffill', 'linear', etc.)</li>\n<li><strong>enforce_single_freq</strong>:  is there a single frequency in the original dataframe</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;],</span><span class=\"param\">\ttz: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;datetime.tzinfo&#x27;&gt;],</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">enforce_single_freq</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.forward_fill_final_record", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.forward_fill_final_record", "kind": "function", "doc": "<p>Forward-fill last record</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\tgap_frequency: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;],</span><span class=\"param\">\tcut_off_frequency: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;] = None</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.interpolate_daily_to_sub_daily_data", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.interpolate_daily_to_sub_daily_data", "kind": "function", "doc": "<p>Interpolate daily data in a dataframe (with a DatetimeIndex) to sub-daily data using a given method.\nThe last daily record is resampled using a forward-fill in any case.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong>:  pd.DataFrame</li>\n<li><strong>freq</strong>:  a frequency &lt; 'D' (e.g. 'H', '30min', '15min', etc)</li>\n<li><strong>tz</strong>:  the time zone (None not accepted because important)</li>\n<li><strong>index_name</strong>:  name to give to the new index. Usually going from 'date' to 'time'.</li>\n<li><strong>method</strong>:  how are data interpolated between two consecutive dates (e.g. 'ffill', 'linear', etc)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pd.DataFrame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;],</span><span class=\"param\">\ttz: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;datetime.tzinfo&#x27;&gt;],</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;ffill&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timeseries.TimeSeries.average_to_upper_freq", "modulename": "enda.tools.timeseries", "qualname": "TimeSeries.average_to_upper_freq", "kind": "function", "doc": "<p>Downsample data provided in a given dataframe with a DatetimeIndex, or a two-levels\ncompatible Multiindex.\nThe provided frequency serves as a basis to group the data and average.\nIf the initial dataframe has no frequency, we raise an error.</p>\n\n<p>Example:</p>\n\n<ol>\n<li>Given df:\ntime_index                value\n2021-01-01 00:00:00+01:00 1\n2021-01-01 00:12:00+01:00 2\n2021-01-02 00:00:00+01:00 3</li>\n</ol>\n\n<p>average_to_upper_freq(df, freq='1D'):\n2021-01-01 00:00:00+01:00 1.5\n2021-01-02 00:00:00+01:00 3</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\tfreq: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;pandas._libs.tslibs.timedeltas.Timedelta&#x27;&gt;],</span><span class=\"param\">\ttz: [&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;datetime.tzinfo&#x27;&gt;],</span><span class=\"param\">\t<span class=\"n\">index_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">enforce_single_freq</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils", "modulename": "enda.tools.timezone_utils", "kind": "module", "doc": "<p>This module contains various functions for dealing with timezones in temporal data in Python</p>\n"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils", "kind": "class", "doc": "<p>This class contains various methods for helping deal with timezones</p>\n"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.is_timezone_aware", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.is_timezone_aware", "kind": "function", "doc": "<p>Check if a datetime /timestamp is timezone-aware or not</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.add_interval_to_day_dt", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.add_interval_to_day_dt", "kind": "function", "doc": "<p>Adds an interval (not more precise than a day) to a day,\n correctly dealing with timezone-aware (and naive) day_dt;\n works around daylight savings time changes.</p>\n\n<p>Normally, to add an interval to a day which is not timezone aware, simply use:\n    day_dt + interval.\nThis does not work properly for timezone-aware days, so we added this function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>day_dt</strong>:  a timezone_aware datetime which is a day (hour=minute=seconds=microsecond=0)</li>\n<li><strong>interval</strong>:  an interval of type relativedelta not more precise than a day</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">day_dt</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">interval</span><span class=\"p\">:</span> <span class=\"n\">dateutil</span><span class=\"o\">.</span><span class=\"n\">relativedelta</span><span class=\"o\">.</span><span class=\"n\">relativedelta</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.add_interval_to_date_object", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.add_interval_to_date_object", "kind": "function", "doc": "<p>If day is a date or not timezone aware, we simply add a correct relativedelta object.\nElse, we have to call add_interval_to_day_dt() to handle the DST change time</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>date_obj</strong>:  a date, a datetime, or a pd.Timestamp</li>\n<li><strong>interval</strong>:  an interval of type relativedelta not more precise than a day.\nNote that the more general Timeseries.add_timedelta() wraps this function and should be preferred.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">date_obj</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">interval</span><span class=\"p\">:</span> <span class=\"n\">dateutil</span><span class=\"o\">.</span><span class=\"n\">relativedelta</span><span class=\"o\">.</span><span class=\"n\">relativedelta</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timestamps</span><span class=\"o\">.</span><span class=\"n\">Timestamp</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.set_timezone", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.set_timezone", "kind": "function", "doc": "<p>Make:</p>\n\n<ul>\n<li>a single-datetime-indexed dataframe's index timezone-aware or convert it to a target timezone.</li>\n<li>a time series timezone-aware or convert it to a target timezone.\nIf the time series is time zone naive:</li>\n</ul>\n\n<blockquote>\n  <p>if tz_base is None, the function localize the time series to tz_info.\n  if tz_base is given, the function localize the time series to  tz_base and convert it to tz_info\n  If the time series is time zone aware, the function converts it to the provided tz_info,\n  whatever the value of tz_base</p>\n</blockquote>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>time_series</strong>:  a datetimeindex, a series, or a dataframe with a datetime index</li>\n<li><strong>tz_info</strong>:  the target time zone</li>\n<li><strong>tz_base</strong>:  optional, the base time zone if we know it while the time series is time zone naive.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the dataframe with the index in the new time zone</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">time_series</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tz_base</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.convert_dtype_from_object_to_tz_aware", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.convert_dtype_from_object_to_tz_aware", "kind": "function", "doc": "<p>Sometimes a time series is of pandas type \"object\" just because the time-zone information\nis not well-read initially. Such a series can't be translated to a pd.DatetimeIndex.\nThis function makes sure the time zone information of the input series is set to the input\ntz_info for each row and also for the series.</p>\n\n<p>Example :\ntime_series = a time_series with some times at timezone +01:00 (French winter time)\n              and others at timezone +02:00 (French summer)\n              So its pandas dtype is \"object\"\ntz = pytz.timezone(\"Europe/Paris\")</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>time_series</strong>:  a series with tz-aware date-times. If a datetime-index is passed, the function\nprocess it</li>\n<li><strong>tz_info</strong>:  a str or a datetime.tzinfo</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a DatetimeIndex of dtype: datetime[ns, tzinfo]</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\ttime_series: [&lt;class &#x27;pandas.core.series.Series&#x27;&gt;, &lt;class &#x27;pandas.core.indexes.datetimes.DatetimeIndex&#x27;&gt;],</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">timezone</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "enda.tools.timezone_utils.TimezoneUtils.read_csv_and_set_tz_aware_columns", "modulename": "enda.tools.timezone_utils", "qualname": "TimezoneUtils.read_csv_and_set_tz_aware_columns", "kind": "function", "doc": "<p>Given a file path, read it and set datetime columns to tz-aware columns</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  path to a csv file</li>\n<li><strong>time_cols_list</strong>:  list of columns that contain time information to set to the correct time zone.</li>\n<li><strong>tz_info</strong>:  a str or a datetime.tzinfo</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a Dataframe with date columns translated into the correct target timezone.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">time_cols_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tz_info</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">tzinfo</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();